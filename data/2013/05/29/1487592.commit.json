{
  "when": "2013-05-29T14:55:01-04:00", 
  "message": "Applying patch for SYNAPSE-893 .Thanks Buddhima Wijeweera for contribution. ", 
  "who": "charith", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-73,6 +73,28", 
          "lines": [
            "     }\n", 
            " \n", 
            "     /**\n", 
            "+     * Test the Message Processor Creation and Serialization\n", 
            "+     * For a Basic Message processor with expressions.\n", 
            "+     */\n", 
            "+    public void testMesssageProcessorSerializationWithExpressions() {\n", 
            "+        String messageProcessorConfig = \"<syn:messageProcessor xmlns:syn=\\\"\" +\n", 
            "+                                        \"http://ws.apache.org/ns/synapse\\\"\" +\n", 
            "+                                        \" name=\\\"foo\\\" \" +\n", 
            "+                                        \"class=\\\"org.apache.synapse.config.xml.MessageProcessorSerializationTest$TestMessageProcessor\\\" messageStore=\\\"bar\\\">\" +\n", 
            "+                                        \"<syn:parameter name=\\\"testName0\\\" xmlns:ns1=\\\"http://namespace1.synapse.org\\\" expression=\\\"//ns1:section/ns1:subSection\\\"/>\"+\n", 
            "+                                        \"<syn:parameter name=\\\"testName1\\\">testValue1</syn:parameter>\" +\n", 
            "+                                        \"<syn:parameter name=\\\"testName2\\\">testValue2</syn:parameter>\" +\n", 
            "+                                        \"</syn:messageProcessor>\";\n", 
            "+\n", 
            "+        OMElement messageProcessorElement = createOMElement(messageProcessorConfig);\n", 
            "+        MessageProcessor messageProcessor = MessageProcessorFactory.createMessageProcessor(messageProcessorElement);\n", 
            "+        OMElement serializedElement = MessageProcessorSerializer.serializeMessageProcessor(null,\n", 
            "+                                                                                           messageProcessor);\n", 
            "+\n", 
            "+        assertTrue(compare(messageProcessorElement, serializedElement));\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "      * This is a Test Message Processor implementation used only to test the XML Serialization\n", 
            "      */\n", 
            "     @SuppressWarnings(\"unused\")\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/config/xml/MessageProcessorSerializationTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/config/xml/MessageProcessorSerializationTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-25,6 +25,8", 
          "lines": [
            " import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.SynapseException;\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\n", 
            "+import org.apache.synapse.util.xpath.SynapseXPath;\n", 
            "+import org.jaxen.JaxenException;\n", 
            " \n", 
            " import javax.xml.namespace.QName;\n", 
            " import java.util.HashMap;\n"
          ]
        }, 
        {
          "locn": "-47,10 +49,11", 
          "lines": [
            "     private static final Log log = LogFactory.getLog(MessageProcessorFactory.class);\n", 
            "     public static final QName CLASS_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"class\");\n", 
            "     public static final QName NAME_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"name\");\n", 
            "+    public static final QName EXPRESSION_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"expression\");\n", 
            "     public static final QName PARAMETER_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE,\n", 
            "-            \"parameter\");\n", 
            "-    public static final QName MESSAGE_STORE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE ,\n", 
            "-            \"messageStore\");\n", 
            "+                                                      \"parameter\");\n", 
            "+    public static final QName MESSAGE_STORE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE,\n", 
            "+                                                          \"messageStore\");\n", 
            "     private static final QName DESCRIPTION_Q\n", 
            "             = new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"description\");\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-57,14 +60,15", 
          "lines": [
            " \n", 
            "     /**\n", 
            "      * Creates a Message processor instance from given xml configuration element\n", 
            "+     *\n", 
            "      * @param elem OMElement of that contain the Message processor configuration\n", 
            "-     * @return  created message processor instance\n", 
            "+     * @return created message processor instance\n", 
            "      */\n", 
            "     public static MessageProcessor createMessageProcessor(OMElement elem) {\n", 
            "         MessageProcessor processor = null;\n", 
            "         OMAttribute clssAtt = elem.getAttribute(CLASS_Q);\n", 
            " \n", 
            "-        if(clssAtt != null) {\n", 
            "+        if (clssAtt != null) {\n", 
            "             try {\n", 
            "                 Class cls = Class.forName(clssAtt.getAttributeValue());\n", 
            "                 processor = (MessageProcessor) cls.newInstance();\n"
          ]
        }, 
        {
          "locn": "-86,7 +90,7", 
          "lines": [
            " \n", 
            "         OMAttribute storeAtt = elem.getAttribute(MESSAGE_STORE_Q);\n", 
            " \n", 
            "-        if(storeAtt != null) {\n", 
            "+        if (storeAtt != null) {\n", 
            "             assert processor != null;\n", 
            "             processor.setMessageStoreName(storeAtt.getAttributeValue());\n", 
            "         } else {\n"
          ]
        }, 
        {
          "locn": "-115,9 +119,19", 
          "lines": [
            "                 OMElement prop = (OMElement) o;\n", 
            "                 OMAttribute paramName = prop.getAttribute(NAME_Q);\n", 
            "                 String paramValue = prop.getText();\n", 
            "+                OMAttribute paramExpression = prop.getAttribute(EXPRESSION_Q);\n", 
            "                 if (paramName != null) {\n", 
            "-                    if (paramValue != null) {\n", 
            "+                    if (paramExpression != null) {\n", 
            "+                        try {\n", 
            "+                            SynapseXPath expression = SynapseXPathFactory.getSynapseXPath(prop, paramExpression.getAttributeValue());\n", 
            "+                            parameters.put(paramName.getAttributeValue(), expression);\n", 
            "+                        } catch (JaxenException e) {\n", 
            "+                            handleException(\"Error while creating expression \" + e.getMessage());\n", 
            "+                        }\n", 
            "+                    } else if (paramValue != null) {\n", 
            "                         parameters.put(paramName.getAttributeValue(), paramValue);\n", 
            "+                    } else {\n", 
            "+                        handleException(\"Invalid MessageStore parameter - Parameter must have a value or an expression \");\n", 
            "                     }\n", 
            "                 } else {\n", 
            "                     handleException(\"Invalid MessageStore parameter - Parameter must have a name \");\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-27,6 +27,7", 
          "lines": [
            " import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.SynapseException;\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\n", 
            "+import org.apache.synapse.util.xpath.SynapseXPath;\n", 
            " \n", 
            " import javax.xml.namespace.QName;\n", 
            " import java.util.Iterator;\n"
          ]
        }, 
        {
          "locn": "-39,6 +40,7", 
          "lines": [
            "  * &lt;parameter name=\"string\"&gt\"string\" &lt;parameter&gt;\n", 
            "  * &lt;parameter name=\"string\"&gt\"string\" &lt;parameter&gt;\n", 
            "  * &lt;parameter name=\"string\"&gt\"string\" &lt;parameter&gt;\n", 
            "+ * &lt;parameter name=\"string\" expression=\"string\"&gt;\n", 
            "  * .\n", 
            "  * .\n", 
            "  * &lt;/messageProcessor&gt;\n"
          ]
        }, 
        {
          "locn": "-55,15 +57,17", 
          "lines": [
            " \n", 
            "     /**\n", 
            "      * Serialize a give Message processor instance to XML configuration\n", 
            "-     * @param parent parent configuration\n", 
            "+     *\n", 
            "+     * @param parent    parent configuration\n", 
            "      * @param processor message processor instance\n", 
            "-     * @return  created XML configuration\n", 
            "+     * @return created XML configuration\n", 
            "      */\n", 
            "-    public static OMElement serializeMessageProcessor(OMElement parent, MessageProcessor processor) {\n", 
            "+    public static OMElement serializeMessageProcessor(OMElement parent,\n", 
            "+                                                      MessageProcessor processor) {\n", 
            "         OMElement processorElem = fac.createOMElement(\"messageProcessor\", synNS);\n", 
            "         if (processor != null) {\n", 
            "             processorElem.addAttribute(fac.createOMAttribute(\"class\", nullNS,\n", 
            "-                    processor.getClass().getName()));\n", 
            "+                                                             processor.getClass().getName()));\n", 
            "         } else {\n", 
            "             handleException(\"Invalid processor. Provider is required\");\n", 
            "         }\n"
          ]
        }, 
        {
          "locn": "-74,9 +78,9", 
          "lines": [
            "             handleException(\"Message store Name not specified\");\n", 
            "         }\n", 
            " \n", 
            "-        if(processor.getMessageStoreName() != null) {\n", 
            "+        if (processor.getMessageStoreName() != null) {\n", 
            "             processorElem.addAttribute(fac.createOMAttribute(\n", 
            "-                    \"messageStore\",nullNS,processor.getMessageStoreName()));\n", 
            "+                    \"messageStore\", nullNS, processor.getMessageStoreName()));\n", 
            "         }\n", 
            " \n", 
            "         if (processor.getParameters() != null) {\n"
          ]
        }, 
        {
          "locn": "-83,12 +87,23", 
          "lines": [
            "             Iterator iterator = processor.getParameters().keySet().iterator();\n", 
            "             while (iterator.hasNext()) {\n", 
            "                 String name = (String) iterator.next();\n", 
            "-                String value = (String) processor.getParameters().get(name);\n", 
            "+                Object object = processor.getParameters().get(name);\n", 
            "                 OMElement property = fac.createOMElement(\"parameter\", synNS);\n", 
            "                 property.addAttribute(fac.createOMAttribute(\n", 
            "                         \"name\", nullNS, name));\n", 
            "-                property.setText(value.trim());\n", 
            "+\n", 
            "+                if (object instanceof String) {\n", 
            "+                    String value = (String) object;\n", 
            "+                    property.setText(value.trim());\n", 
            "+\n", 
            "+                } else if (object instanceof SynapseXPath) {\n", 
            "+                    SynapseXPath expression = (SynapseXPath) object;\n", 
            "+                    SynapseXPathSerializer.serializeXPath(expression,property,\"expression\");\n", 
            "+\n", 
            "+                }\n", 
            "+\n", 
            "                 processorElem.addChild(property);\n", 
            "+\n", 
            "             }\n", 
            "         }\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,344", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.message.processors.resequence;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.message.processors.ScheduledMessageProcessor;\n", 
            "+import org.apache.synapse.message.store.MessageStore;\n", 
            "+import org.apache.synapse.util.xpath.SynapseXPath;\n", 
            "+import org.quartz.JobDataMap;\n", 
            "+import org.quartz.JobDetail;\n", 
            "+import org.quartz.SchedulerException;\n", 
            "+\n", 
            "+import java.util.concurrent.atomic.AtomicBoolean;\n", 
            "+import java.util.concurrent.atomic.AtomicInteger;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This class will be used as the processor of the resequencer and set up\n", 
            "+ * the necessary environment for the ReequencingJob.\n", 
            "+ * This should be run periodically after given time interval and\n", 
            "+ * for that this should be inherited from ScheduledMessageProcessor class\n", 
            "+ */\n", 
            "+public class ResequencingProcessor extends ScheduledMessageProcessor {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Log is set to the current class\n", 
            "+     */\n", 
            "+    private static final Log log = LogFactory.getLog(ResequencingProcessor.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * State of the processor\n", 
            "+     */\n", 
            "+    private AtomicBoolean active = new AtomicBoolean(true);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To indicate whether the starting sequence number is set while initializing the processor\n", 
            "+     */\n", 
            "+    private AtomicBoolean initSeqNo = new AtomicBoolean(false);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Sequence number of the message that should be send next\n", 
            "+     */\n", 
            "+    private AtomicInteger nextSeqNo = new AtomicInteger(Integer.MAX_VALUE);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Number of messages interested to come\n", 
            "+     * Number of messages that the Resequencing processor should wait for before selecting the starting sequence number.\n", 
            "+     * Default value is 4\n", 
            "+     */\n", 
            "+    private AtomicInteger requiredInitMsgs = new AtomicInteger(4);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Time to wait for interested number of messages to come\n", 
            "+     */\n", 
            "+    private AtomicInteger requiredInitMsgsDelay = new AtomicInteger(5);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * xpath expression to extract the sequence number\n", 
            "+     */\n", 
            "+    public static final String SEQUENCE_NUMBER_XPATH = \"seqNumXpath\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Sequence that the messages should be passed to\n", 
            "+     */\n", 
            "+    public static final String NEXT_SEQUENCE = \"nextEsbSequence\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Required initial number of messages\n", 
            "+     */\n", 
            "+    public static final String REQ_INIT_MSGS = \"requiredInitMessages\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Delay until getting required number of messages receive\n", 
            "+     */\n", 
            "+    public static final String REQ_INIT_MSGS_DELAY = \"requiredInitMessagesDelay\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Delay time period required for Resequencer processor while initializing starting sequence number\n", 
            "+     */\n", 
            "+    public static final int STARTING_NUMBER_INIT_DELAY = 6000;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Number of times currently processor waited until required number of messages come\n", 
            "+     * Max value is determined by   requiredInitMsgs variable value\n", 
            "+     */\n", 
            "+    public int tried = 0;\n", 
            "+\n", 
            "+    public static final String DELETE_DUPLICATES=\"deleteDuplicateMessages\";\n", 
            "+\n", 
            "+    private AtomicBoolean deleteDuplicates=new AtomicBoolean(false);\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Initiate the processor with SynapseEnvironment\n", 
            "+     *\n", 
            "+     * @param se - SynapseEnvironment to be set\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    public void init(SynapseEnvironment se) {\n", 
            "+        super.init(se);\n", 
            "+\n", 
            "+        /** Set the initial sequence number */\n", 
            "+        findFirstSeqNum();\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method use to find the minimum sequence number in the message store at the startup\n", 
            "+     */\n", 
            "+    private void findFirstSeqNum() {\n", 
            "+\n", 
            "+\n", 
            "+        MessageStore store = configuration.getMessageStore(messageStore);\n", 
            "+        SynapseXPath seqNoxPath = null;\n", 
            "+\n", 
            "+        /** Extract the SynapseXpath configuration.getMessageStore(messageStore)object from parameters to\n", 
            "+         * identify the sequence number of the message */\n", 
            "+        if (parameters != null && parameters.get(ResequencingProcessor.SEQUENCE_NUMBER_XPATH) != null) {\n", 
            "+            seqNoxPath = (SynapseXPath) parameters.get(ResequencingProcessor.SEQUENCE_NUMBER_XPATH);\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        /** Iterate through message store */\n", 
            "+        for (int messageIndex = 0; ; messageIndex++) {\n", 
            "+\n", 
            "+            try {\n", 
            "+                MessageContext messageContext = store.get(messageIndex);\n", 
            "+                if (messageContext == null) {\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+\n", 
            "+                /** Extract the sequence number from the message */\n", 
            "+                int sequenceNo = Integer.parseInt(seqNoxPath.stringValueOf(messageContext));\n", 
            "+\n", 
            "+                /** If the sequence number is smaller that current next-sequence number, current next-sequence\n", 
            "+                 * number get replaced */\n", 
            "+                if (sequenceNo < getNextSeqNo()) {\n", 
            "+                    setNextSeqNo(sequenceNo);\n", 
            "+                    /** To indicate that starting sequence number is initialized */\n", 
            "+                    initSeqNo = new AtomicBoolean(true);\n", 
            "+                }\n", 
            "+\n", 
            "+            } catch (NumberFormatException e) {\n", 
            "+                handleException(\"Invalid xPath parameter - Sequence number specified is not an integer \");\n", 
            "+            } catch (Exception e) {\n", 
            "+                handleException(\"Failed to initialize starting sequence number at startup: \" + e.getMessage());\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get the job details with Name and Job Class\n", 
            "+     *\n", 
            "+     * @return jobDetail - created JobDetail object with Name and JobClass\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    protected JobDetail getJobDetail() {\n", 
            "+        JobDetail jobDetail = new JobDetail();\n", 
            "+        jobDetail.setName(name + \"-resequensing-job\");\n", 
            "+        jobDetail.setJobClass(ResequencingJob.class);\n", 
            "+        return jobDetail;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get the map that contains parameters related  to Resequencing job\n", 
            "+     *\n", 
            "+     * @return jobDataMap - created Job Data Map along with the processor instance\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    protected JobDataMap getJobDataMap() {\n", 
            "+        JobDataMap jdm = new JobDataMap();\n", 
            "+        jdm.put(PROCESSOR_INSTANCE, this);\n", 
            "+        return jdm;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Destroy the processor's resequencing job\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    public void destroy() {\n", 
            "+        try {\n", 
            "+            scheduler.deleteJob(name + \"-resequensing-job\",\n", 
            "+                    ScheduledMessageProcessor.SCHEDULED_MESSAGE_PROCESSOR_GROUP);\n", 
            "+        } catch (SchedulerException e) {\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Activate the Resequencing processor\n", 
            "+     * Set the active value to true\n", 
            "+     */\n", 
            "+    public void activate() {\n", 
            "+        active.set(true);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Check if the processor is active or not\n", 
            "+     *\n", 
            "+     * @return active - boolean expression that tells the status of the processor\n", 
            "+     */\n", 
            "+    public boolean isActive() {\n", 
            "+        return active.get();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * De-activate the resequencing processor\n", 
            "+     * Set the active value to false\n", 
            "+     */\n", 
            "+    public void deactivate() {\n", 
            "+        active.set(false);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the next sequence number\n", 
            "+     *\n", 
            "+     * @return nextSeqNo - The sequence number of the message that to be send next\n", 
            "+     */\n", 
            "+    public synchronized int getNextSeqNo() {\n", 
            "+        return nextSeqNo.get();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method allow to change the value of nextSeqNo variable, which is used to determine\n", 
            "+     * the sequence number of the message next to go\n", 
            "+     *\n", 
            "+     * @param value - The value to set\n", 
            "+     */\n", 
            "+    public synchronized void setNextSeqNo(int value) {\n", 
            "+        nextSeqNo.set(value);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Increase the sequence number by one\n", 
            "+     */\n", 
            "+    public synchronized void incrementNextSeqNo() {\n", 
            "+        nextSeqNo.incrementAndGet();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Indicate whether the initial sequencer number is set\n", 
            "+     *\n", 
            "+     * @return initSeqNo - boolean value containing true or false\n", 
            "+     */\n", 
            "+    public AtomicBoolean isInitSeqNo() {\n", 
            "+        return initSeqNo;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Set or clear the initSeqNo value\n", 
            "+     *\n", 
            "+     * @param initSeqNo - boolean value to set\n", 
            "+     */\n", 
            "+    public void setInitSeqNo(AtomicBoolean initSeqNo) {\n", 
            "+        this.initSeqNo = initSeqNo;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get the number initial messages required before set starting sequence number\n", 
            "+     *\n", 
            "+     * @return requiredInitMsgs - int value of required messages\n", 
            "+     */\n", 
            "+    public AtomicInteger getRequiredInitMsgs() {\n", 
            "+        return requiredInitMsgs;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Set the number of messages required before set starting sequence number\n", 
            "+     *\n", 
            "+     * @param requiredInitMsgs - number of messages need to wait\n", 
            "+     */\n", 
            "+    public void setRequiredInitMsgs(AtomicInteger requiredInitMsgs) {\n", 
            "+        this.requiredInitMsgs = requiredInitMsgs;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Delay until requiredInitMsgs get set\n", 
            "+     *\n", 
            "+     * @return requiredInitMessagesDelay delay value\n", 
            "+     */\n", 
            "+    public AtomicInteger getRequiredInitMsgsDelay() {\n", 
            "+        return requiredInitMsgsDelay;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Set the delay until requiredInitMsgs get set\n", 
            "+     *\n", 
            "+     * @param requiredInitMsgsDelay - value for delay\n", 
            "+     */\n", 
            "+    public void setRequiredInitMsgsDelay(AtomicInteger requiredInitMsgsDelay) {\n", 
            "+        this.requiredInitMsgsDelay = requiredInitMsgsDelay;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Check whether to delete duplicate messages or not\n", 
            "+     * @return   value of deleteDuplicates\n", 
            "+     */\n", 
            "+    public boolean getDeleteDuplicates() {\n", 
            "+        return deleteDuplicates.get();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Set to delete duplicate messages\n", 
            "+     * @param deleteDuplicates\n", 
            "+     */\n", 
            "+    public void setDeleteDuplicates(AtomicBoolean deleteDuplicates) {\n", 
            "+        this.deleteDuplicates = deleteDuplicates;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Handling errors are done here.\n", 
            "+     * This will log the error messages and throws SynapseException\n", 
            "+     *\n", 
            "+     * @param msg - Error message to be set\n", 
            "+     * @throws org.apache.synapse.SynapseException\n", 
            "+     *          - Exception related to Synapse at Runtime\n", 
            "+     */\n", 
            "+    private static void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/message/processors/resequence/ResequencingProcessor.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/message/processors/resequence/ResequencingProcessor.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,273", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.message.processors.resequence;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.message.processors.MessageProcessorConsents;\n", 
            "+import org.apache.synapse.message.processors.ScheduledMessageProcessor;\n", 
            "+import org.apache.synapse.message.store.MessageStore;\n", 
            "+import org.apache.synapse.util.xpath.SynapseXPath;\n", 
            "+import org.quartz.Job;\n", 
            "+import org.quartz.JobDataMap;\n", 
            "+import org.quartz.JobExecutionContext;\n", 
            "+import org.quartz.JobExecutionException;\n", 
            "+\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.atomic.AtomicBoolean;\n", 
            "+import java.util.concurrent.atomic.AtomicInteger;\n", 
            "+\n", 
            "+/**\n", 
            "+ * All necessary logic for Resequencing is implemented with in this class.\n", 
            "+ * This class extends from Job class which comes from Quartz\n", 
            "+ */\n", 
            "+public class ResequencingJob implements Job {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Log is set to the current class\n", 
            "+     */\n", 
            "+    private static final Log log = LogFactory.getLog(ResequencingJob.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method will takes the necessary parameters from parameter list and do the resequencing\n", 
            "+     * Resequencing is done through reading messages until the next-to-send message is found\n", 
            "+     * If required is not found then waits until the next instance is created.\n", 
            "+     *\n", 
            "+     * @param jobExecutionContext - a bundle with information related to environment\n", 
            "+     * @throws JobExecutionException - to indicate Quartz scheduler that an error occurred while executing the job\n", 
            "+     */\n", 
            "+    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {\n", 
            "+\n", 
            "+        final JobDataMap jdm = jobExecutionContext.getMergedJobDataMap();\n", 
            "+        final MessageStore messageStore = (MessageStore) jdm.get(MessageProcessorConsents.MESSAGE_STORE);\n", 
            "+        final ResequencingProcessor processor = (ResequencingProcessor) jdm.get(\n", 
            "+                ScheduledMessageProcessor.PROCESSOR_INSTANCE);\n", 
            "+\n", 
            "+        final Map<String, Object> parameters = (Map<String, Object>) jdm.get(MessageProcessorConsents.PARAMETERS);\n", 
            "+        final String sequence = (String) parameters.get(ResequencingProcessor.NEXT_SEQUENCE);\n", 
            "+\n", 
            "+        SynapseXPath seqNoxPath = null;\n", 
            "+\n", 
            "+        /** Checking for activation of processor or existence of message store  */\n", 
            "+        if (!processor.isActive() || messageStore == null) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        /** Extract the SynapseXpath object from parameters to identify the sequence number of the message */\n", 
            "+        if (parameters != null && parameters.get(ResequencingProcessor.SEQUENCE_NUMBER_XPATH) != null) {\n", 
            "+            seqNoxPath = (SynapseXPath) parameters.get(ResequencingProcessor.SEQUENCE_NUMBER_XPATH);\n", 
            "+        }\n", 
            "+\n", 
            "+        /** Extract the number of messages interested to come */\n", 
            "+        if (parameters != null && parameters.get(ResequencingProcessor.REQ_INIT_MSGS) != null) {\n", 
            "+            processor.setRequiredInitMsgs(new AtomicInteger(Integer.parseInt((String) parameters.get(\n", 
            "+                    ResequencingProcessor.REQ_INIT_MSGS))));\n", 
            "+        }\n", 
            "+        /** Extract the delay wait until the interested messages come */\n", 
            "+        if (parameters != null && parameters.get(ResequencingProcessor.REQ_INIT_MSGS_DELAY) != null) {\n", 
            "+            processor.setRequiredInitMsgsDelay(new AtomicInteger(Integer.parseInt((String) parameters.get(\n", 
            "+                    ResequencingProcessor.REQ_INIT_MSGS_DELAY))));\n", 
            "+        }\n", 
            "+\n", 
            "+        /** Extract whether to delete duplicate messages */\n", 
            "+        if (parameters != null && parameters.get(ResequencingProcessor.DELETE_DUPLICATES) != null) {\n", 
            "+            String result=(String) parameters.get(ResequencingProcessor.DELETE_DUPLICATES);\n", 
            "+            if(result.equalsIgnoreCase(\"TRUE\")){\n", 
            "+                processor.setDeleteDuplicates(new AtomicBoolean(true));\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        if (!processor.isInitSeqNo().get()) {\n", 
            "+            /** Deactivating Resequencing processor to avoid executing multiple Job instances */\n", 
            "+            processor.deactivate();\n", 
            "+\n", 
            "+            do {\n", 
            "+                delay(ResequencingProcessor.STARTING_NUMBER_INIT_DELAY);\n", 
            "+\n", 
            "+                if (messageStore.size() >= processor.getRequiredInitMsgs().get()) {\n", 
            "+                    selectStartingSeqNo(processor, messageStore, seqNoxPath);\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+                processor.tried++;\n", 
            "+            } while (processor.tried < processor.getRequiredInitMsgsDelay().get());\n", 
            "+\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!processor.isInitSeqNo().get()) {\n", 
            "+\n", 
            "+            while (true) {\n", 
            "+\n", 
            "+                if (messageStore.size() > 0) {\n", 
            "+                    selectStartingSeqNo(processor, messageStore, seqNoxPath);\n", 
            "+\n", 
            "+                    if (!processor.isInitSeqNo().get()) {\n", 
            "+                        log.warn(\"Resequencer failed to select starting sequence number with in given timeout !\");\n", 
            "+                    }\n", 
            "+\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+\n", 
            "+        /** Continue to this section happens only after initializing the starting sequence number */\n", 
            "+        boolean errorStop = false;\n", 
            "+        while (!errorStop) {\n", 
            "+\n", 
            "+            /** Iterate through message store */\n", 
            "+            for (int messageIndex = 0; ; messageIndex++) {\n", 
            "+                MessageContext messageContext = messageStore.get(messageIndex);\n", 
            "+\n", 
            "+                if (messageContext == null) {\n", 
            "+                    errorStop = true;\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+\n", 
            "+                /** Extract the sequence number from the message */\n", 
            "+                int sequenceNo;\n", 
            "+                try {\n", 
            "+                    sequenceNo = Integer.parseInt(seqNoxPath.stringValueOf(messageContext));\n", 
            "+                } catch (Exception e) {\n", 
            "+                    log.warn(\"Can't Find sequence number from message \" + e.getMessage());\n", 
            "+                    continue;\n", 
            "+                }\n", 
            "+\n", 
            "+                String messageId = messageContext.getMessageID();\n", 
            "+\n", 
            "+                /** Remove messages which have less sequence number than required */\n", 
            "+                if(sequenceNo<processor.getNextSeqNo() && processor.getDeleteDuplicates()){\n", 
            "+                    messageStore.remove(messageId);\n", 
            "+                }\n", 
            "+\n", 
            "+                /** Compare the next-to-go sequence number with current message sequence number */\n", 
            "+                if (sequenceNo == processor.getNextSeqNo()) {\n", 
            "+\n", 
            "+                    /** Remove selected message from store */\n", 
            "+\n", 
            "+                    messageStore.remove(messageId);\n", 
            "+                    /** If sending does not failed increase sequence number */\n", 
            "+                    if (send(messageContext, sequence)) {\n", 
            "+\n", 
            "+                        processor.incrementNextSeqNo();\n", 
            "+                    }\n", 
            "+                    /** Break and start searching from beginning */\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+\n", 
            "+\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+\n", 
            "+        /** Reactivating Processor after selecting initial sequence number */\n", 
            "+        if (!processor.isActive()) {\n", 
            "+            processor.activate();\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Selects the smallest sequence number as the starting sequence number from a given message store\n", 
            "+     *\n", 
            "+     * @param processor    - Resequencing processor which is interested to know starting sequence number\n", 
            "+     * @param messageStore - Message store that contains messages\n", 
            "+     * @param seqNoxPath   - SynapseXpath object which contains the xpath to find the sequence number from a message\n", 
            "+     */\n", 
            "+    private void selectStartingSeqNo(ResequencingProcessor processor, MessageStore messageStore,\n", 
            "+                                     SynapseXPath seqNoxPath) {\n", 
            "+        /** Iterate through message store */\n", 
            "+        for (int messageIndex = 0; ; messageIndex++) {\n", 
            "+            try {\n", 
            "+                MessageContext messageContext = messageStore.get(messageIndex);\n", 
            "+                if (messageContext == null) {\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+                /** Extract the sequence number from the message */\n", 
            "+                int sequenceNo;\n", 
            "+\n", 
            "+                sequenceNo = Integer.parseInt(seqNoxPath.stringValueOf(messageContext));\n", 
            "+\n", 
            "+\n", 
            "+                /** If the sequence number is smaller that current next-sequence number, current next-sequence number get replaced */\n", 
            "+                if (sequenceNo < processor.getNextSeqNo()) {\n", 
            "+                    processor.setNextSeqNo(sequenceNo);\n", 
            "+                    processor.setInitSeqNo(new AtomicBoolean(true));\n", 
            "+                }\n", 
            "+\n", 
            "+\n", 
            "+            } catch (NumberFormatException e) {\n", 
            "+                handleException(\"Invalid xPath parameter - Sequence number specified is not an integer \");\n", 
            "+            } catch (Exception e) {\n", 
            "+                handleException(\"Failed to initialize starting sequence number at startup: \" + e.getMessage());\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To timePeriod the processor until next checking up\n", 
            "+     * This method is in use wen initializing the starting sequence number of the resequencer\n", 
            "+     *\n", 
            "+     * @param timePeriod - the time period which waits before a single cycle\n", 
            "+     */\n", 
            "+    private void delay(long timePeriod) {\n", 
            "+        try {\n", 
            "+            Thread.sleep(timePeriod);\n", 
            "+        } catch (InterruptedException e) {\n", 
            "+            log.error(new String(\"Interrupted while thread sleeping in resequencer\"));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Transmit the message in to a given sequence\n", 
            "+     * This method will takes the sequence given in sequence parameter. If no sequence is given this will return false     *\n", 
            "+     *\n", 
            "+     * @param messageContext - the content of the message that is transferred by Resequencer from message store\n", 
            "+     * @param sequence       - the sequence name that the message should be passed\n", 
            "+     * @return boolean         - to indicate the success of transferring the message\n", 
            "+     */\n", 
            "+    private boolean send(MessageContext messageContext, String sequence) {\n", 
            "+\n", 
            "+        Mediator processingSequence = messageContext.getSequence(sequence);\n", 
            "+        if (processingSequence != null) {\n", 
            "+            processingSequence.mediate(messageContext);\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Handling errors are done here.\n", 
            "+     * This will log the error messages and throws SynapseException\n", 
            "+     *\n", 
            "+     * @param msg - Error message to be set\n", 
            "+     * @throws SynapseException - Exception related to Synapse at Runtime\n", 
            "+     */\n", 
            "+    private static void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/message/processors/resequence/ResequencingJob.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/message/processors/resequence/ResequencingJob.java"
    }
  ], 
  "id": "1487592"
}