{
  "when": "2011-12-06T07:34:02-05:00", 
  "message": "Access logs and a few bug fixes", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-0,0 +1,181", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.nhttp.util;\n", 
            "+\n", 
            "+import org.apache.synapse.transport.nhttp.AccessConstants;\n", 
            "+\n", 
            "+import java.text.SimpleDateFormat;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.TimeZone;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Utility methods related to the Access Time\n", 
            "+ */\n", 
            "+public class AccessTimeUtil {\n", 
            "+\n", 
            "+    private static String calculateTimeZoneOffset(long offset) {\n", 
            "+        StringBuilder tz = new StringBuilder();\n", 
            "+        if ((offset < 0)) {\n", 
            "+            tz.append(\"-\");\n", 
            "+            offset = -offset;\n", 
            "+        } else {\n", 
            "+            tz.append(\"+\");\n", 
            "+        }\n", 
            "+\n", 
            "+        long hourOffset = offset / (1000 * 60 * 60);\n", 
            "+        long minuteOffset = (offset / (1000 * 60)) % 60;\n", 
            "+\n", 
            "+        if (hourOffset < 10) {\n", 
            "+            tz.append(\"0\");\n", 
            "+        }\n", 
            "+        tz.append(hourOffset);\n", 
            "+\n", 
            "+        if (minuteOffset < 10) {\n", 
            "+            tz.append(\"0\");\n", 
            "+        }\n", 
            "+        tz.append(minuteOffset);\n", 
            "+\n", 
            "+        return tz.toString();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * gets the timezone +/-{****}}, offset from GMT,\n", 
            "+     * @return String time zone (eg, +0530, -0600).\n", 
            "+     */\n", 
            "+    public static String getTimeZone() {\n", 
            "+        try {\n", 
            "+            int offset = TimeZone.getDefault().getRawOffset();\n", 
            "+            return calculateTimeZoneOffset(offset);\n", 
            "+        } catch (Exception e) {\n", 
            "+            return \"\";\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * AccessDateStruct Class\n", 
            "+     */\n", 
            "+    private static class AccessDateStruct {\n", 
            "+        private Date currentDate = new Date();\n", 
            "+        private String currentDateString = null;\n", 
            "+        private SimpleDateFormat dayFormatter = new SimpleDateFormat(\"dd\");\n", 
            "+        private SimpleDateFormat monthFormatter = new SimpleDateFormat(\"MM\");\n", 
            "+        private SimpleDateFormat yearFormatter = new SimpleDateFormat(\"yyyy\");\n", 
            "+\n", 
            "+        private SimpleDateFormat timeFormatter = new SimpleDateFormat(\"HH:mm:ss\");\n", 
            "+\n", 
            "+        public AccessDateStruct() {\n", 
            "+            TimeZone tz = TimeZone.getDefault();\n", 
            "+            dayFormatter.setTimeZone(tz);\n", 
            "+            monthFormatter.setTimeZone(tz);\n", 
            "+            yearFormatter.setTimeZone(tz);\n", 
            "+            timeFormatter.setTimeZone(tz);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The system time when we last updated the Date, that is used for log lines.\n", 
            "+     */\n", 
            "+    private static final ThreadLocal<AccessDateStruct> currentDateStruct =\n", 
            "+            new ThreadLocal<AccessDateStruct>() {\n", 
            "+                @Override\n", 
            "+                protected AccessDateStruct initialValue() {\n", 
            "+                    return new AccessDateStruct();\n", 
            "+                }\n", 
            "+            };\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method returns a Date object that is accurate to within one second.\n", 
            "+     * If a thread calls this method to get a Date and it's been less than 1\n", 
            "+     * second since a new Date was created, this method simply gives out the\n", 
            "+     * same Date again so that the system doesn't spend time creating Date\n", 
            "+     * objects unnecessarily.\n", 
            "+     *\n", 
            "+     * @return Date\n", 
            "+     */\n", 
            "+    public static Date getDate() {\n", 
            "+        // Only create a new Date once per second, max.\n", 
            "+        long systime = System.currentTimeMillis();\n", 
            "+        AccessDateStruct struct = currentDateStruct.get();\n", 
            "+        if ((systime - struct.currentDate.getTime()) > 1000) {\n", 
            "+            struct.currentDate.setTime(systime);\n", 
            "+            struct.currentDateString = null;\n", 
            "+        }\n", 
            "+        return struct.currentDate;\n", 
            "+    }\n", 
            "+\n", 
            "+    private static AccessDateStruct getAccessDateStruct(Date date) {\n", 
            "+        AccessDateStruct struct = currentDateStruct.get();\n", 
            "+        if (struct.currentDateString == null) {\n", 
            "+            StringBuilder current = new StringBuilder(32);\n", 
            "+            current.append('[');\n", 
            "+            current.append(struct.dayFormatter.format(date));\n", 
            "+            current.append('/');\n", 
            "+            current.append(lookup(struct.monthFormatter.format(date)));\n", 
            "+            current.append('/');\n", 
            "+            current.append(struct.yearFormatter.format(date));\n", 
            "+            current.append(':');\n", 
            "+            current.append(struct.timeFormatter.format(date));\n", 
            "+            current.append(' ');\n", 
            "+            current.append(AccessTimeUtil.getTimeZone());\n", 
            "+            current.append(']');\n", 
            "+            struct.currentDateString = current.toString();\n", 
            "+        }\n", 
            "+        return struct;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Return the month abbreviation for the specified month, which must\n", 
            "+     * be a two-digit String.\n", 
            "+     *\n", 
            "+     * @param month Month number (\"01\" .. \"12\").\n", 
            "+     * @return - the month\n", 
            "+     */\n", 
            "+    private static String lookup(String month) {\n", 
            "+        int index;\n", 
            "+        try {\n", 
            "+            index = Integer.parseInt(month) - 1;\n", 
            "+        } catch (Throwable t) {\n", 
            "+            handleThrowable(t);\n", 
            "+            index = 0;  // Can not happen, in theory\n", 
            "+        }\n", 
            "+        return (AccessConstants.MONTHS[index]);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getAccessDate(Date date) {\n", 
            "+         AccessDateStruct struct = getAccessDateStruct(date);\n", 
            "+        return struct.currentDateString;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Checks whether the supplied Throwable is one that needs to be\n", 
            "+     * re-thrown and swallows all others.\n", 
            "+     *\n", 
            "+     * @param t the Throwable to check\n", 
            "+     */\n", 
            "+    public static void handleThrowable(Throwable t) {\n", 
            "+        if (t instanceof ThreadDeath) {\n", 
            "+            throw (ThreadDeath) t;\n", 
            "+        }\n", 
            "+        if (t instanceof VirtualMachineError) {\n", 
            "+            throw (VirtualMachineError) t;\n", 
            "+        }\n", 
            "+        // All other instances of Throwable will be silently swallowed\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/AccessTimeUtil.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/AccessTimeUtil.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,59", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.nhttp;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Constants used in the Access Class\n", 
            "+ */\n", 
            "+public class AccessConstants {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Pattern used to log - Default is COMBINED_PATTERN given below.\n", 
            "+     */\n", 
            "+    public static final String COMBINED_PATTERN =\n", 
            "+            \"%h %l %u %t \\\"%r\\\" %s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The set of month abbreviations for log messages.\n", 
            "+     */\n", 
            "+    public static final String MONTHS[] =\n", 
            "+            {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n", 
            "+             \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The directory in which log files are created.\n", 
            "+     */\n", 
            "+    public static String DIRECTORY = \"repository/logs\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Gives the format of the date to be appended to the name of the access log file.\n", 
            "+     */\n", 
            "+    public static String FILE_FORMAT = \"yyyy-MM-dd\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The prefix that is added to log file file names.\n", 
            "+     */\n", 
            "+    public static String PREFIX = \"http_access_\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The suffix that is added to log file file names.\n", 
            "+     */\n", 
            "+    public static String SUFFIX = \".log\";\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessConstants.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,40", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.nhttp;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Handles the Access, providing an Access object.\n", 
            "+ */\n", 
            "+public class AccessHandler {\n", 
            "+\n", 
            "+    public final static String ACCESS_LOG_ID = \"org.apache.synapse.transport.nhttp.access\";\n", 
            "+\n", 
            "+    private final static Log accessLog = LogFactory.getLog(ACCESS_LOG_ID);\n", 
            "+\n", 
            "+    private static final AccessLogger accessLogger = new AccessLogger(accessLog);\n", 
            "+\n", 
            "+    private static final Access access = new Access(accessLog, accessLogger);\n", 
            "+\n", 
            "+    public static Access getAccess() {\n", 
            "+        return access;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,227", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.nhttp;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+\n", 
            "+import java.io.BufferedWriter;\n", 
            "+import java.io.File;\n", 
            "+import java.io.FileWriter;\n", 
            "+import java.io.IOException;\n", 
            "+import java.io.PrintWriter;\n", 
            "+import java.text.SimpleDateFormat;\n", 
            "+import java.util.Date;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Class that logs the Http Accesses to the access log files. Code segment borrowed from\n", 
            "+ * Apache Tomcat's org.apache.catalina.valves.AccessLogValve with thanks.\n", 
            "+ */\n", 
            "+public class AccessLogger {\n", 
            "+\n", 
            "+    public final static String ACCESS_LOG_ID = \"org.apache.synapse.transport.nhttp.access\";\n", 
            "+    private static Log log = LogFactory.getLog(ACCESS_LOG_ID);\n", 
            "+\n", 
            "+    public AccessLogger(final Log log) {\n", 
            "+        super();\n", 
            "+        this.initOpen();\n", 
            "+        AccessLogger.log = log;\n", 
            "+        buffered = true;\n", 
            "+        checkExists = false;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * A date formatter to format a Date into a date in the given file format\n", 
            "+     */\n", 
            "+    protected SimpleDateFormat fileDateFormatter =\n", 
            "+            new SimpleDateFormat(AccessConstants.FILE_FORMAT);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The PrintWriter to which we are currently logging, if any.\n", 
            "+     */\n", 
            "+    protected PrintWriter writer;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The as-of date for the currently open log file, or a zero-length\n", 
            "+     * string if there is no open log file.\n", 
            "+     */\n", 
            "+    private volatile String dateStamp = \"\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Instant when the log daily rotation was last checked.\n", 
            "+     */\n", 
            "+    private volatile long rotationLastChecked = 0L;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Buffered logging.\n", 
            "+     */\n", 
            "+    private boolean buffered = true;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Do we check for log file existence? Helpful if an external\n", 
            "+     * agent renames the log file so we can automatically recreate it.\n", 
            "+     */\n", 
            "+    private boolean checkExists = false;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The current log file we are writing to. Helpful when checkExists\n", 
            "+     * is true.\n", 
            "+     */\n", 
            "+    protected File currentLogFile = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Can the log file be rotated.\n", 
            "+     */\n", 
            "+    protected boolean isRotatable = true;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Log the specified message to the log file, switching files if the date\n", 
            "+     * has changed since the previous log call.\n", 
            "+     *\n", 
            "+     * @param message Message to be logged\n", 
            "+     */\n", 
            "+    public void log(String message) {\n", 
            "+        if (isRotatable) {\n", 
            "+            // Only do a logfile switch check once a second, max.\n", 
            "+            long systemTime = System.currentTimeMillis();\n", 
            "+            if ((systemTime - rotationLastChecked) > 1000) {\n", 
            "+                synchronized (this) {\n", 
            "+                    if ((systemTime - rotationLastChecked) > 1000) {\n", 
            "+                        rotationLastChecked = systemTime;\n", 
            "+\n", 
            "+                        String tsDate;\n", 
            "+                        // Check for a change of date\n", 
            "+                        tsDate = fileDateFormatter.format(new Date(systemTime));\n", 
            "+\n", 
            "+                        // If the date has changed, switch log files\n", 
            "+                        if (!dateStamp.equals(tsDate)) {\n", 
            "+                            close();\n", 
            "+                            dateStamp = tsDate;\n", 
            "+                            open();\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        /* In case something external rotated the file instead */\n", 
            "+        if (checkExists) {\n", 
            "+            synchronized (this) {\n", 
            "+                if (currentLogFile != null && !currentLogFile.exists()) {\n", 
            "+                    try {\n", 
            "+                        close();\n", 
            "+                    } catch (Throwable e) {\n", 
            "+                        handleThrowable(e);\n", 
            "+                        log.info(\"Access Log file Close failed\");\n", 
            "+                    }\n", 
            "+\n", 
            "+                    /* Make sure date is correct */\n", 
            "+                    dateStamp = fileDateFormatter.format(\n", 
            "+                            new Date(System.currentTimeMillis()));\n", 
            "+\n", 
            "+                    open();\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        // Log this message\n", 
            "+        synchronized (this) {\n", 
            "+            if (writer != null) {\n", 
            "+                writer.println(message);\n", 
            "+\n", 
            "+                if (!buffered) {\n", 
            "+                    writer.flush();\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    protected synchronized void initOpen() {\n", 
            "+        /* Make sure date is correct */\n", 
            "+        dateStamp = fileDateFormatter.format(\n", 
            "+                new Date(System.currentTimeMillis()));\n", 
            "+        this.open();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Open the new log file for the date specified by <code>dateStamp</code>.\n", 
            "+     */\n", 
            "+    protected synchronized void open() {\n", 
            "+        // Create the directory if necessary\n", 
            "+        File dir = new File(AccessConstants.DIRECTORY);\n", 
            "+        if (!dir.exists()) {\n", 
            "+            if (!dir.mkdirs()) {\n", 
            "+                log.error(\"Access Log Open Directory Failed\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        // Open the current log file\n", 
            "+        try {\n", 
            "+            String pathName;\n", 
            "+            // If no rotate - no need for dateStamp in fileName\n", 
            "+            if (isRotatable) {\n", 
            "+                pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX +\n", 
            "+                           dateStamp + AccessConstants.SUFFIX;\n", 
            "+            } else {\n", 
            "+                pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX +\n", 
            "+                           AccessConstants.SUFFIX;\n", 
            "+            }\n", 
            "+\n", 
            "+            writer = new PrintWriter(new BufferedWriter(new FileWriter(\n", 
            "+                    pathName, true), 128000), true);\n", 
            "+\n", 
            "+            currentLogFile = new File(pathName);\n", 
            "+        } catch (IOException e) {\n", 
            "+            log.warn(\"Unable to open the print writer\", e);\n", 
            "+            writer = null;\n", 
            "+            currentLogFile = null;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Close the currently open log file (if any)\n", 
            "+     */\n", 
            "+    synchronized void close() {\n", 
            "+        if (writer == null) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+        writer.flush();\n", 
            "+        writer.close();\n", 
            "+        writer = null;\n", 
            "+        dateStamp = \"\";\n", 
            "+        currentLogFile = null;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Checks whether the supplied Throwable is one that needs to be\n", 
            "+     * re-thrown and swallows all others.\n", 
            "+     *\n", 
            "+     * @param t the Throwable to check\n", 
            "+     */\n", 
            "+    public static void handleThrowable(Throwable t) {\n", 
            "+        if (t instanceof ThreadDeath) {\n", 
            "+            throw (ThreadDeath) t;\n", 
            "+        }\n", 
            "+        if (t instanceof VirtualMachineError) {\n", 
            "+            throw (VirtualMachineError) t;\n", 
            "+        }\n", 
            "+        // All other instances of Throwable will be silently swallowed\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessLogger.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/AccessLogger.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-476,6 +476,9", 
          "lines": [
            "             response.setHeader(\n", 
            "                 HTTP.CONTENT_TYPE,\n", 
            "                 messageFormatter.getContentType(msgContext, format, msgContext.getSoapAction()));\n", 
            "+        } else if ( Boolean.TRUE == noEntityBody) {\n", 
            "+            ((BasicHttpEntity)response.getEntity()).setChunked(false);\n", 
            "+            ((BasicHttpEntity)response.getEntity()).setContentLength(0);\n", 
            "         }\n", 
            "         response.setStatusCode(determineHttpStatusCode(msgContext, response));\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,811", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.nhttp;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.http.Header;\n", 
            "+import org.apache.http.HttpMessage;\n", 
            "+import org.apache.http.HttpRequest;\n", 
            "+import org.apache.http.HttpResponse;\n", 
            "+import org.apache.synapse.transport.nhttp.util.AccessTimeUtil;\n", 
            "+\n", 
            "+import java.net.InetAddress;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Timer;\n", 
            "+import java.util.TimerTask;\n", 
            "+import java.util.concurrent.ConcurrentLinkedQueue;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The class to handle the HTTP Access Logs, patterns and the major functionality.\n", 
            "+ * Major Code segment borrowed from Apache Tomcat's\n", 
            "+ * org.apache.catalina.valves.AccessLogValve with thanks.\n", 
            "+ */\n", 
            "+public class Access {\n", 
            "+    private static Log log = LogFactory.getLog(Access.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Array of AccessLogElement, they will be used to make log message.\n", 
            "+     */\n", 
            "+    protected AccessLogElement[] logElements = null;\n", 
            "+\n", 
            "+    protected String pattern = AccessConstants.COMBINED_PATTERN;\n", 
            "+\n", 
            "+    private static AccessLogger accessLogger;\n", 
            "+\n", 
            "+    private static ConcurrentLinkedQueue<HttpRequest> requestQueue;\n", 
            "+    private static ConcurrentLinkedQueue<HttpResponse> responseQueue;\n", 
            "+\n", 
            "+    private static final int LOG_FREQUENCY_IN_SECONDS = 30;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Constructor of AccessLog. AccessHandler has a static object of Access.\n", 
            "+     *\n", 
            "+     * @param log          - Log passed as a param. Default is Log of the same class.\n", 
            "+     * @param accessLogger - AccessLogger Object\n", 
            "+     */\n", 
            "+    public Access(final Log log, AccessLogger accessLogger) {\n", 
            "+        super();\n", 
            "+        Access.log = log;\n", 
            "+        Access.accessLogger = accessLogger;\n", 
            "+        requestQueue = new ConcurrentLinkedQueue<HttpRequest>();\n", 
            "+        responseQueue = new ConcurrentLinkedQueue<HttpResponse>();\n", 
            "+        logElements = createLogElements();\n", 
            "+        logAccesses();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Adds the accesses to the queue.\n", 
            "+     *\n", 
            "+     * @param request - HttpRequest\n", 
            "+     */\n", 
            "+    public void addAccessToQueue(HttpRequest request) {\n", 
            "+        requestQueue.add(request);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Adds the accesses to the queue.\n", 
            "+     *\n", 
            "+     * @param response - HttpResponse\n", 
            "+     */\n", 
            "+    public void addAccessToQueue(HttpResponse response) {\n", 
            "+        responseQueue.add(response);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * logs the request and response accesses.\n", 
            "+     */\n", 
            "+    public void logAccesses() {\n", 
            "+        TimerTask logRequests = new LogRequests();\n", 
            "+        TimerTask logResponses = new LogResponses();\n", 
            "+        Timer requestTimer = new Timer();\n", 
            "+        Timer responseTimer = new Timer();\n", 
            "+        // Retry in 30 seconds\n", 
            "+        long retryIn = 1000 * LOG_FREQUENCY_IN_SECONDS;\n", 
            "+        requestTimer.schedule(logRequests, 0, retryIn);\n", 
            "+        responseTimer.schedule(logResponses, 0, retryIn);\n", 
            "+    }\n", 
            "+\n", 
            "+    private class LogRequests extends TimerTask {\n", 
            "+        public void run() {\n", 
            "+            while (!requestQueue.isEmpty()) {\n", 
            "+                HttpRequest req = requestQueue.poll();\n", 
            "+                log(req, null);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private class LogResponses extends TimerTask {\n", 
            "+        public void run() {\n", 
            "+            while (!responseQueue.isEmpty()) {\n", 
            "+                HttpResponse res = responseQueue.poll();\n", 
            "+                log(null, res);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The log method that is called from the NHttpClient and Server connection classes.\n", 
            "+     *\n", 
            "+     * @param request  - HttpRequest\n", 
            "+     * @param response - HttpResponse\n", 
            "+     */\n", 
            "+    public void log(HttpRequest request, HttpResponse response) {\n", 
            "+        Date date = AccessTimeUtil.getDate();\n", 
            "+        StringBuilder result = new StringBuilder(128);\n", 
            "+\n", 
            "+        for (AccessLogElement logElement : logElements) {\n", 
            "+            logElement.addElement(result, date, request, response);\n", 
            "+        }\n", 
            "+        String logString = result.toString();\n", 
            "+        log.debug(logString);      //log to the console\n", 
            "+        accessLogger.log(logString);      //log to the file\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * gets the header values from the given message, with the given name.\n", 
            "+     *\n", 
            "+     * @param message - The message, HttpRequest or HttpResponse\n", 
            "+     * @param name    - The header, which we need to get the value of.\n", 
            "+     * @return - The header value.\n", 
            "+     */\n", 
            "+    protected static String getHeaderValues(HttpMessage message, String name) {\n", 
            "+        int length = 0;\n", 
            "+        Header[] header = new Header[0];\n", 
            "+        StringBuffer headerValue = new StringBuffer();\n", 
            "+        try {\n", 
            "+            header = message.getHeaders(name);\n", 
            "+            length = header.length;\n", 
            "+        } catch (Exception e) {\n", 
            "+            // The header doesn't exist\n", 
            "+        }\n", 
            "+        if (length == 0) {\n", 
            "+            return \"-\";\n", 
            "+        } else if (length == 1) {\n", 
            "+            return header[0].getValue();\n", 
            "+        } else {\n", 
            "+            headerValue.append(header[0].getValue());\n", 
            "+            for (int i = 1; i < length; i++) {\n", 
            "+                headerValue.append(\" - \").append(header[i].getValue());\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return headerValue.toString();\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getHostElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Host\"); //%h;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getLogicalUserNameElement(HttpMessage message) {\n", 
            "+        if (message != null) {  //%l\n", 
            "+            return \"-\";\n", 
            "+        }\n", 
            "+        return \"\";\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getUserNameElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"From\");     //%u\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getCookieElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Cookie\");      // %c\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getRefererElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Referer\"); //%{Referer}i;           %f\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getUserAgentElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"User-Agent\");           //%{User-Agent} %a\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getAcceptElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Accept\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getAcceptLanguageElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Accept-Language\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getAcceptEncodingElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Accept-Encoding\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getAcceptCharSetElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Accept-Charset\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getConnectionElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Connection\");       //Keep-Alive\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getContentTypeElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Content-Type\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getKeepAliveElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Keep-Alive\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getTransferEncodingElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Transfer-Encoding\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getContentEncodingElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Content-Encoding\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getVaryElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Vary\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getServerElement(HttpMessage message) {\n", 
            "+        return getHeaderValues(message, \"Server\");\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * AccessLogElement writes the partial message into the buffer.\n", 
            "+     */\n", 
            "+    protected interface AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write local IP address - %A\n", 
            "+     */\n", 
            "+    protected static class LocalAddrElement implements AccessLogElement {\n", 
            "+\n", 
            "+        private static final String LOCAL_ADDR_VALUE;\n", 
            "+\n", 
            "+        static {\n", 
            "+            String init;\n", 
            "+            try {\n", 
            "+                init = InetAddress.getLocalHost().getHostAddress();\n", 
            "+            } catch (Throwable e) {\n", 
            "+                AccessTimeUtil.handleThrowable(e);\n", 
            "+                init = \"127.0.0.1\";\n", 
            "+            }\n", 
            "+            LOCAL_ADDR_VALUE = init;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(LOCAL_ADDR_VALUE);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write remote host name - %h\n", 
            "+     */\n", 
            "+    protected static class HostElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            String host = \"\";\n", 
            "+            try {\n", 
            "+                host = getHostElement(request);\n", 
            "+            } catch (Exception e) {\n", 
            "+                // empty host\n", 
            "+            }\n", 
            "+            buf.append(host);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write remote logical username from identd (always returns '-') - %l\n", 
            "+     */\n", 
            "+    protected static class LogicalUserNameElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            String logicalUserName = \"\";\n", 
            "+            try {\n", 
            "+                logicalUserName = getLogicalUserNameElement(request);\n", 
            "+            } catch (Exception e) {\n", 
            "+                // empty logicalUserName\n", 
            "+            }\n", 
            "+            buf.append(logicalUserName);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write remote user that was authenticated (if any), else '-' - %u\n", 
            "+     */\n", 
            "+    protected static class UserElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            String userElement = \"\";\n", 
            "+            try {\n", 
            "+                userElement = getUserNameElement(request);\n", 
            "+            } catch (Exception e) {\n", 
            "+                // empty UserName\n", 
            "+            }\n", 
            "+            buf.append(userElement);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write date and time, in Common Log Format - %t\n", 
            "+     */\n", 
            "+    protected class DateAndTimeElement implements AccessLogElement {\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            String currentDate = \"\";\n", 
            "+            if (request != null) {\n", 
            "+                currentDate = getHeaderValues(request, \"Date\");\n", 
            "+            } else if (response != null) {\n", 
            "+                currentDate = getHeaderValues(response, \"Date\");\n", 
            "+            }\n", 
            "+            buf.append(currentDate);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write first line of the request (method and request URI) - %r\n", 
            "+     */\n", 
            "+    protected static class RequestElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            if (request != null) {\n", 
            "+                String requestLine = request.getRequestLine().toString();\n", 
            "+                buf.append(requestLine);\n", 
            "+            } else {\n", 
            "+                buf.append(\"- - \");\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write HTTP status code of the response - %s\n", 
            "+     */\n", 
            "+    protected static class HttpStatusCodeElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            if (response != null) {\n", 
            "+                int statusCode = response.getStatusLine().getStatusCode();\n", 
            "+                buf.append(statusCode); //getStatus\n", 
            "+            } else {\n", 
            "+                buf.append('-');\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write bytes sent, excluding HTTP headers - %b, %B\n", 
            "+     */\n", 
            "+    protected static class ByteSentElement implements AccessLogElement {\n", 
            "+        private boolean conversion;\n", 
            "+\n", 
            "+        /**\n", 
            "+         * if conversion is true, write '-' instead of 0 - %b\n", 
            "+         *\n", 
            "+         * @param conversion - To be conversed.\n", 
            "+         */\n", 
            "+        public ByteSentElement(boolean conversion) {\n", 
            "+            this.conversion = conversion;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            // Don't need to flush since trigger for log message is after the\n", 
            "+            // response has been committed\n", 
            "+            try {\n", 
            "+                long length = response.getEntity().getContentLength(); //getBytesWritten(false);\n", 
            "+                if (length <= 0 && conversion) {\n", 
            "+                    buf.append('-');                           //%b\n", 
            "+                } else {\n", 
            "+                    buf.append(length);\n", 
            "+                }\n", 
            "+            } catch (Exception e) {\n", 
            "+                buf.append('-'); //No entity found.\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write request method (GET, POST, etc.) - %m\n", 
            "+     */\n", 
            "+    protected static class MethodElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            if (request != null) {\n", 
            "+                buf.append(request.getRequestLine().getMethod());\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write requested URL path - %U\n", 
            "+     */\n", 
            "+    protected static class RequestURIElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            if (request != null) {\n", 
            "+                buf.append(request.getRequestLine().getUri());\n", 
            "+            } else {\n", 
            "+                buf.append('-');\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write local server name - %v\n", 
            "+     */\n", 
            "+    protected static class LocalServerNameElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getHeaderValues(request, \"server\"));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write any string\n", 
            "+     */\n", 
            "+    protected static class StringElement implements AccessLogElement {\n", 
            "+        private String str;\n", 
            "+\n", 
            "+        public StringElement(String str) {\n", 
            "+            this.str = str;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(str);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write incoming headers - %{xxx}i\n", 
            "+     */\n", 
            "+    protected static class HeaderElement implements AccessLogElement {\n", 
            "+        private String header;\n", 
            "+\n", 
            "+        public HeaderElement(String header) {\n", 
            "+            this.header = header;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            try {\n", 
            "+                String value = getHeaderValues(request, header);\n", 
            "+                if (value == null) {\n", 
            "+                    buf.append('-');\n", 
            "+                } else {\n", 
            "+                    buf.append(value);\n", 
            "+                }\n", 
            "+            } catch (Exception e) {\n", 
            "+                buf.append('-'); //Header is null\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write a specific cookie - %{xxx}c\n", 
            "+     */\n", 
            "+    protected static class CookieElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getCookieElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the referer - %f\n", 
            "+     */\n", 
            "+    protected static class RefererElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getRefererElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the user agent - %a\n", 
            "+     */\n", 
            "+    protected static class UserAgentElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getUserAgentElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Accept Element - %C\n", 
            "+     */\n", 
            "+    protected static class AcceptElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getAcceptElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Accept Language Element - %L\n", 
            "+     */\n", 
            "+    protected static class AcceptLanguageElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getAcceptLanguageElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Accept Encoding Element - %e\n", 
            "+     */\n", 
            "+    protected static class AcceptEncodingElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getAcceptEncodingElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Accept Character Set Element - %S\n", 
            "+     */\n", 
            "+    protected static class AcceptCharSetElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getAcceptCharSetElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Connection Element - %x\n", 
            "+     */\n", 
            "+    protected static class ConnectionElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getConnectionElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Content Type Element - %T\n", 
            "+     */\n", 
            "+    protected static class ContentTypeElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getContentTypeElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Keep Alive Element - %k\n", 
            "+     */\n", 
            "+    protected static class KeepAliveElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getKeepAliveElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Transfer Encoding Element - %E\n", 
            "+     */\n", 
            "+    protected static class TransferEncodingElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getTransferEncodingElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Content Encoding Element - %n\n", 
            "+     */\n", 
            "+    protected static class ContentEncodingElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getContentEncodingElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Vary Element - %V\n", 
            "+     */\n", 
            "+    protected static class VaryElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getVaryElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write the Server Element - %Z\n", 
            "+     */\n", 
            "+    protected static class ServerElement implements AccessLogElement {\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            buf.append(getServerElement(request));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write a specific response header - %{xxx}o\n", 
            "+     */\n", 
            "+    protected static class ResponseHeaderElement implements AccessLogElement {\n", 
            "+        private String header;\n", 
            "+\n", 
            "+        public ResponseHeaderElement(String header) {\n", 
            "+            this.header = header;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            if (null != response) {\n", 
            "+                buf.append(getHeaderValues(response, header));\n", 
            "+            }\n", 
            "+            buf.append(\"-\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * write an attribute in the ServletRequest - %{xxx}r    %R\n", 
            "+     */\n", 
            "+    protected static class RequestAttributeElement implements AccessLogElement {\n", 
            "+\n", 
            "+        public RequestAttributeElement() {\n", 
            "+        }\n", 
            "+\n", 
            "+        public void addElement(StringBuilder buf, Date date, HttpRequest request,\n", 
            "+                               HttpResponse response) {\n", 
            "+            Object value;\n", 
            "+            if (request != null) {\n", 
            "+                value = request.getLastHeader(buf.toString()); //gets the attribute header\n", 
            "+            } else {\n", 
            "+                value = \"??\";\n", 
            "+            }\n", 
            "+            if (value != null) {\n", 
            "+                if (value instanceof String) {\n", 
            "+                    buf.append((String) value);\n", 
            "+                } else {\n", 
            "+                    buf.append(value.toString());\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                buf.append('-');\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * parse pattern string and create the array of AccessLogElement\n", 
            "+     *\n", 
            "+     * @return Array of AccessLogElement\n", 
            "+     */\n", 
            "+    protected AccessLogElement[] createLogElements() {\n", 
            "+        List<AccessLogElement> list = new ArrayList<AccessLogElement>();\n", 
            "+        boolean replace = false;\n", 
            "+        StringBuilder buf = new StringBuilder();\n", 
            "+        for (int i = 0; i < pattern.length(); i++) {\n", 
            "+            char ch = pattern.charAt(i);\n", 
            "+            if (replace) {\n", 
            "+                /*\n", 
            "+                 * For code that processes {, the behavior will be ... if I do\n", 
            "+                 * not encounter a closing } - then I ignore the {\n", 
            "+                 */\n", 
            "+                if ('{' == ch) {\n", 
            "+                    StringBuilder name = new StringBuilder();\n", 
            "+                    int j = i + 1;\n", 
            "+                    for (; j < pattern.length() && '}' != pattern.charAt(j); j++) {\n", 
            "+                        name.append(pattern.charAt(j));\n", 
            "+                    }\n", 
            "+                    if (j + 1 < pattern.length()) {\n", 
            "+                        /* the +1 was to account for } which we increment now */\n", 
            "+                        j++;\n", 
            "+                        list.add(createAccessLogElement(name.toString(),\n", 
            "+                                                        pattern.charAt(j)));\n", 
            "+                        i = j; /* Since we walked more than one character */\n", 
            "+                    } else {\n", 
            "+                        // D'oh - end of string - pretend we never did this\n", 
            "+                        // and do processing the \"old way\"\n", 
            "+                        list.add(createAccessLogElement(ch));\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    list.add(createAccessLogElement(ch));\n", 
            "+                }\n", 
            "+                replace = false;\n", 
            "+            } else if (ch == '%') {\n", 
            "+                replace = true;\n", 
            "+                list.add(new StringElement(buf.toString()));\n", 
            "+                buf = new StringBuilder();\n", 
            "+            } else {\n", 
            "+                buf.append(ch);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if (buf.length() > 0) {\n", 
            "+            list.add(new StringElement(buf.toString()));\n", 
            "+        }\n", 
            "+        return list.toArray(new AccessLogElement[list.size()]);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * create an AccessLogElement implementation which needs header string\n", 
            "+     *\n", 
            "+     * @param header  - header of the request/response\n", 
            "+     * @param pattern - pattern character given for the input element\n", 
            "+     * @return AccessLogElement - accessLogElement\n", 
            "+     */\n", 
            "+    private AccessLogElement createAccessLogElement(String header, char pattern) {\n", 
            "+        switch (pattern) {\n", 
            "+            case 'i':\n", 
            "+                return new HeaderElement(header);  //%{xxx}i\n", 
            "+            case 'o':\n", 
            "+                return new ResponseHeaderElement(header);\n", 
            "+            case 'R':\n", 
            "+                return new RequestAttributeElement();\n", 
            "+            default:\n", 
            "+                return new StringElement(\"???\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * create an AccessLogElement implementation\n", 
            "+     *\n", 
            "+     * @param pattern - pattern character given for the input element\n", 
            "+     * @return AccessLogElement acceessLogElement\n", 
            "+     */\n", 
            "+    private AccessLogElement createAccessLogElement(char pattern) {\n", 
            "+        switch (pattern) {\n", 
            "+            case 'A':\n", 
            "+                return new LocalAddrElement();\n", 
            "+            case 'a':\n", 
            "+                return new UserAgentElement();\n", 
            "+            case 'b':\n", 
            "+                return new ByteSentElement(true);     //%b\n", 
            "+            case 'B':\n", 
            "+                return new ByteSentElement(false);\n", 
            "+            case 'c':\n", 
            "+                return new CookieElement();            // %c\n", 
            "+            case 'C':\n", 
            "+                return new AcceptElement();\n", 
            "+            case 'e':\n", 
            "+                return new AcceptEncodingElement();\n", 
            "+            case 'E':\n", 
            "+                return new TransferEncodingElement();\n", 
            "+            case 'f':\n", 
            "+                return new RefererElement();\n", 
            "+            case 'h':\n", 
            "+                return new HostElement();         //%h\n", 
            "+            case 'k':\n", 
            "+                return new KeepAliveElement();\n", 
            "+            case 'l':\n", 
            "+                return new LogicalUserNameElement();     //%l\n", 
            "+            case 'L':\n", 
            "+                return new AcceptLanguageElement();\n", 
            "+            case 'm':\n", 
            "+                return new MethodElement();\n", 
            "+            case 'n':\n", 
            "+                return new ContentEncodingElement();\n", 
            "+            case 'r':\n", 
            "+                return new RequestElement();        //%r\n", 
            "+            case 'S':\n", 
            "+                return new AcceptCharSetElement();\n", 
            "+            case 's':\n", 
            "+                return new HttpStatusCodeElement();       // %s\n", 
            "+            case 'T':\n", 
            "+                return new ContentTypeElement();\n", 
            "+            case 't':\n", 
            "+                return new DateAndTimeElement();       //%t\n", 
            "+            case 'u':\n", 
            "+                return new UserElement();           //%u\n", 
            "+            case 'U':\n", 
            "+                return new RequestURIElement();\n", 
            "+            case 'V':\n", 
            "+                return new VaryElement();\n", 
            "+            case 'v':\n", 
            "+                return new LocalServerNameElement();\n", 
            "+            case 'x':\n", 
            "+                return new ConnectionElement();\n", 
            "+            case 'Z':\n", 
            "+                return new ServerElement();\n", 
            "+            default:\n", 
            "+                return new StringElement(\"???\" + pattern + \"???\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/Access.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/Access.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-43,6 +43,8", 
          "lines": [
            " import javax.xml.stream.XMLStreamException;\n", 
            " import java.io.IOException;\n", 
            " import java.io.InputStream;\n", 
            "+import java.net.URI;\n", 
            "+import java.net.URISyntaxException;\n", 
            " import java.util.Comparator;\n", 
            " import java.util.Map;\n", 
            " import java.util.TreeMap;\n"
          ]
        }, 
        {
          "locn": "-112,6 +114,7", 
          "lines": [
            "                 responseMsgCtx.setOperationContext(outMsgCtx.getOperationContext());\n", 
            "             }\n", 
            " \n", 
            "+            responseMsgCtx.setProperty(MessageContext.IN_MESSAGE_CONTEXT, outMsgCtx);\n", 
            "             responseMsgCtx.setServerSide(true);\n", 
            "             responseMsgCtx.setDoingREST(outMsgCtx.isDoingREST());\n", 
            "             responseMsgCtx.setProperty(MessageContext.TRANSPORT_IN, outMsgCtx\n"
          ]
        }, 
        {
          "locn": "-130,15 +133,35", 
          "lines": [
            "                     }\n", 
            "                 });\n", 
            "                 \n", 
            "-                for (int i=0; i<headers.length; i++) {\n", 
            "+                String servicePrefix = (String)outMsgCtx.getProperty(NhttpConstants.SERVICE_PREFIX);\n", 
            "+                for (int i = 0; i < headers.length; i++) {\n", 
            "                     Header header = headers[i];\n", 
            "-                    if (\"Location\".equals(header.getName())\n", 
            "-                        && endpointURLPrefix != null\n", 
            "-                        && outMsgCtx.getProperty(NhttpConstants.SERVICE_PREFIX) != null) {\n", 
            "-                        \n", 
            "-                        headerMap.put(header.getName(),\n", 
            "-                            header.getValue().replaceAll(endpointURLPrefix,\n", 
            "-                                (String) outMsgCtx.getProperty(NhttpConstants.SERVICE_PREFIX)));\n", 
            "+                    if (\"Location\".equals(header.getName()) &&\n", 
            "+                            endpointURLPrefix != null && servicePrefix != null) {\n", 
            "+                        // Here, we are changing only the host name and the port of the new URI\n", 
            "+                        // value of the Location header.\n", 
            "+                        // If the new URI is again referring to a resource in the server to which the\n", 
            "+                        // original request is sent, then replace the hostname and port of the URI\n", 
            "+                        // with the hostname and port of synapse.\n", 
            "+                        // We are not changing the request url here, only the hostname and the port.\n", 
            "+                        try {\n", 
            "+                            URI serviceURI = new URI(servicePrefix);\n", 
            "+                            URI endpointURI = new URI(endpointURLPrefix);\n", 
            "+                            URI locationURI = new URI(header.getValue());\n", 
            "+\n", 
            "+                            if(locationURI.getHost().equalsIgnoreCase(endpointURI.getHost())){\n", 
            "+                                URI newURI = new URI(locationURI.getScheme(), locationURI.getUserInfo(),\n", 
            "+                                        serviceURI.getHost(), serviceURI.getPort(), locationURI.getPath(),\n", 
            "+                                        locationURI.getQuery(), locationURI.getFragment());\n", 
            "+                                headerMap.put(header.getName(), newURI.toString());\n", 
            "+                                responseMsgCtx.setProperty(NhttpConstants.SERVICE_PREFIX,\n", 
            "+                                        outMsgCtx.getProperty(NhttpConstants.SERVICE_PREFIX));\n", 
            "+                            } else {\n", 
            "+                                headerMap.put(header.getName(), header.getValue());\n", 
            "+                            }\n", 
            "+                        } catch (URISyntaxException e) {\n", 
            "+                            log.error(e.getMessage(), e);\n", 
            "+                        }\n", 
            "                     } else {\n", 
            "                         headerMap.put(header.getName(), header.getValue());\n", 
            "                     }\n"
          ]
        }, 
        {
          "locn": "-278,7 +301,6", 
          "lines": [
            " \n", 
            "         } catch (AxisFault af) {\n", 
            "             log.error(\"Fault creating response SOAP envelope\", af);\n", 
            "-            return;\n", 
            "         } catch (XMLStreamException e) {\n", 
            "             log.error(\"Error creating response SOAP envelope\", e);\n", 
            "         } catch (IOException e) {\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-722,16 +722,25", 
          "lines": [
            "                         MessageContext responseMsgCtx = outMsgCtx.getOperationContext().\n", 
            "                                 getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);\n", 
            "                         if (responseMsgCtx == null ||\n", 
            "+                                outMsgCtx.getOptions().isUseSeparateListener() ||\n", 
            "+                                outMsgCtx.getOperationContext().isComplete()) {\n", 
            "+                            if (responseMsgCtx != null &&\n", 
            "+                                    responseMsgCtx.getProperty(\"synapse.send\") == null) {\n", 
            "+                                return;\n", 
            "+                            }\n", 
            "+                        } else if (responseMsgCtx == null ||\n", 
            "                                 outMsgCtx.getOptions().isUseSeparateListener()) {\n", 
            "                             // Since we need to notify the SynapseCallback receiver to remove the\n", 
            "                             // call backs registered  we set a custom property\n", 
            "-                            if (outMsgCtx.getOperationContext().isComplete()) {\n", 
            "-                                setHeaders(context, response, outMsgCtx, responseMsgCtx);\n", 
            "-                                outMsgCtx.setProperty(NhttpConstants.HTTP_202_RECEIVED, \"true\");\n", 
            "-                                mr.receive(outMsgCtx);\n", 
            "-                            }\n", 
            "+                            setHeaders(context, response, outMsgCtx, responseMsgCtx);\n", 
            "+                            outMsgCtx.setProperty(NhttpConstants.HTTP_202_RECEIVED, \"true\");\n", 
            "+                            mr.receive(outMsgCtx);\n", 
            "                             return;\n", 
            "                         }\n", 
            "+\n", 
            "+                        if (responseMsgCtx == null) {\n", 
            "+                            return;\n", 
            "+                        }\n", 
            "                         setHeaders(context, response, outMsgCtx, responseMsgCtx);\n", 
            "                         responseMsgCtx.setServerSide(true);\n", 
            "                         responseMsgCtx.setDoingREST(outMsgCtx.isDoingREST());\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-127,11 +127,15", 
          "lines": [
            "         } else if (serviceName != null && parameters.containsKey(\"wsdl\")) {\n", 
            "             generateWsdl(request, response, msgContext,\n", 
            "                     conn, os, serviceName, parameters, isRestDispatching);\n", 
            "+            return;\n", 
            "         } else if (serviceName != null && parameters.containsKey(\"wsdl2\")) {\n", 
            "             generateWsdl2(request, response, msgContext,\n", 
            "                     conn, os, serviceName, isRestDispatching);\n", 
            "+            return;\n", 
            "         } else if (serviceName != null && parameters.containsKey(\"xsd\")) {\n", 
            "-            generateXsd(response, conn, os, serviceName, parameters);\n", 
            "+            generateXsd(request, response, msgContext, conn, os, serviceName,\n", 
            "+                    parameters, isRestDispatching);\n", 
            "+            return;\n", 
            "         } else if (serviceName != null && parameters.containsKey(\"info\")) {\n", 
            "             generateServiceDetailsPage(response, conn, os, serviceName);\n", 
            "         } else if (uri.startsWith(servicePath) &&\n"
          ]
        }, 
        {
          "locn": "-144,12 +148,15", 
          "lines": [
            "         }\n", 
            " \n", 
            "         // make sure that the output stream is flushed and closed properly\n", 
            "+        closeOutputStream(os);\n", 
            "+    }\n", 
            "+\n", 
            "+    private void closeOutputStream(OutputStream os) {\n", 
            "         try {\n", 
            "             os.flush();\n", 
            "             os.close();\n", 
            "         } catch (IOException ignore) {\n", 
            "         }\n", 
            "-\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-186,7 +193,7", 
          "lines": [
            "             if (serviceName.startsWith(\"/\")) {\n", 
            "                 serviceName = serviceName.substring(1);\n", 
            "             }\n", 
            "-            if (serviceName.indexOf(\"?\") != -1) {\n", 
            "+            if (serviceName.contains(\"?\")) {\n", 
            "                 serviceName = serviceName.substring(0, serviceName.indexOf(\"?\"));\n", 
            "             }\n", 
            "         } else {\n"
          ]
        }, 
        {
          "locn": "-277,15 +284,19", 
          "lines": [
            "     /**\n", 
            "      * Generates Schema.\n", 
            "      *\n", 
            "+     * @param request     HttpRequest\n", 
            "      * @param response    HttpResponse\n", 
            "+     * @param messageCtx  Current MessageContext\n", 
            "      * @param conn        NHttpServerConnection\n", 
            "      * @param os          OutputStream\n", 
            "      * @param serviceName service name\n", 
            "      * @param parameters  url parameters\n", 
            "+     * @param isRestDispatching Whether to handle this as REST\n", 
            "      */\n", 
            "-    protected void generateXsd(HttpResponse response, NHttpServerConnection conn,\n", 
            "+    protected void generateXsd(HttpRequest request, HttpResponse response,\n", 
            "+                               MessageContext messageCtx, NHttpServerConnection conn,\n", 
            "                                OutputStream os, String serviceName,\n", 
            "-                               Map<String, String> parameters) {\n", 
            "+                               Map<String, String> parameters, boolean isRestDispatching) {\n", 
            "         if (parameters.get(\"xsd\") == null || \"\".equals(parameters.get(\"xsd\"))) {\n", 
            "             AxisService service = cfgCtx.getAxisConfiguration()\n", 
            "                     .getServices().get(serviceName);\n"
          ]
        }, 
        {
          "locn": "-296,11 +307,15", 
          "lines": [
            "                     response.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "                     serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "                     os.write(baos.toByteArray());\n", 
            "+                    closeOutputStream(os);\n", 
            " \n", 
            "                 } catch (Exception e) {\n", 
            "                     handleBrowserException(response, conn, os,\n", 
            "                             \"Error generating ?xsd output for service : \" + serviceName, e);\n", 
            "                 }\n", 
            "+            } else {\n", 
            "+                processGetAndDelete(request, response, messageCtx, conn, os,\n", 
            "+                        serviceName, isRestDispatching);\n", 
            "             }\n", 
            " \n", 
            "         } else {\n"
          ]
        }, 
        {
          "locn": "-330,6 +345,7", 
          "lines": [
            "                         response.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "                         serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "                         os.write(baos.toByteArray());\n", 
            "+                        closeOutputStream(os);\n", 
            "                     } catch (Exception e) {\n", 
            "                         handleBrowserException(response, conn, os,\n", 
            "                                 \"Error generating named ?xsd output for service : \" + serviceName, e);\n"
          ]
        }, 
        {
          "locn": "-338,7 +354,11", 
          "lines": [
            "                 } else {\n", 
            "                     // no schema available by that name  - send 404\n", 
            "                     response.setStatusCode(HttpStatus.SC_NOT_FOUND);\n", 
            "+                    closeOutputStream(os);\n", 
            "                 }\n", 
            "+            } else {\n", 
            "+                processGetAndDelete(request, response, messageCtx, conn, os,\n", 
            "+                        serviceName, isRestDispatching);\n", 
            "             }\n", 
            "         }\n", 
            "     }\n"
          ]
        }, 
        {
          "locn": "-373,6 +393,7", 
          "lines": [
            "                 response.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "                 serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "                 os.write(baos.toByteArray());\n", 
            "+                closeOutputStream(os);\n", 
            " \n", 
            "             } catch (Exception e) {\n", 
            "                 handleBrowserException(response, conn, os,\n"
          ]
        }, 
        {
          "locn": "-416,6 +437,7", 
          "lines": [
            "                 response.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "                 serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "                 os.write(baos.toByteArray());\n", 
            "+                closeOutputStream(os);\n", 
            " \n", 
            "             } catch (Exception e) {\n", 
            "                 handleBrowserException(response, conn, os,\n"
          ]
        }, 
        {
          "locn": "-602,7 +624,7", 
          "lines": [
            "         Hashtable erroneousServices = cfgCtx.getAxisConfiguration().getFaultyServices();\n", 
            "         boolean servicesFound = false;\n", 
            " \n", 
            "-        StringBuffer resultBuf = new StringBuffer();\n", 
            "+        StringBuilder resultBuf = new StringBuilder();\n", 
            "         resultBuf.append(\"<html><head><title>Axis2: Services</title></head>\" + \"<body>\");\n", 
            " \n", 
            "         if ((services != null) && !services.isEmpty()) {\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/DefaultHttpGetProcessor.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/DefaultHttpGetProcessor.java"
    }
  ], 
  "id": "1210886"
}