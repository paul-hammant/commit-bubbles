{
  "when": "2011-12-06T04:31:09-05:00", 
  "message": "Added ServiceDynamicLoadbalanceEndpoint for dynamic load balancing of services. For more details, see ServiceDynamicLoadbalanceEndpoint in http://blog.afkham.org/2011/09/wso2-load-balancer-how-it-works.html", 
  "who": "azeez", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-0,0 +1,67", 
          "lines": [
            "+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", 
            "+<!--\n", 
            "+  ~  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+  ~  or more contributor license agreements.  See the NOTICE file\n", 
            "+  ~  distributed with this work for additional information\n", 
            "+  ~  regarding copyright ownership.  The ASF licenses this file\n", 
            "+  ~  to you under the Apache License, Version 2.0 (the\n", 
            "+  ~  \"License\"); you may not use this file except in compliance\n", 
            "+  ~  with the License.  You may obtain a copy of the License at\n", 
            "+  ~\n", 
            "+  ~   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+  ~\n", 
            "+  ~  Unless required by applicable law or agreed to in writing,\n", 
            "+  ~  software distributed under the License is distributed on an\n", 
            "+  ~   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+  ~  KIND, either express or implied.  See the License for the\n", 
            "+  ~  specific language governing permissions and limitations\n", 
            "+  ~  under the License.\n", 
            "+  -->\n", 
            "+\n", 
            "+<!-- Load balancing between 2 Cloud Services -->\n", 
            "+<definitions xmlns=\"http://ws.apache.org/ns/synapse\">\n", 
            "+\n", 
            "+    <sequence name=\"main\" onError=\"errorHandler\">\n", 
            "+        <in>\n", 
            "+            <property name=\"SERVICE_PREFIX\" expression=\"$axis2:SERVICE_PREFIX\"/>\n", 
            "+            <send>\n", 
            "+                <endpoint name=\"sdlbEndpoint\">\n", 
            "+                    <serviceDynamicLoadbalance failover=\"true\"\n", 
            "+                                               algorithm=\"org.apache.synapse.endpoints.algorithms.RoundRobin\">\n", 
            "+                        <loadBalancerConfig>\n", 
            "+                            <services>\n", 
            "+                                <service>\n", 
            "+                                    <hosts>\n", 
            "+                                        <host>test1.synapse.apache.org</host>\n", 
            "+                                    </hosts>\n", 
            "+                                    <domain>test1.synapse.domain</domain>\n", 
            "+                                </service>\n", 
            "+                                <service>\n", 
            "+                                    <hosts>\n", 
            "+                                        <host>test2.synapse.apache.org</host>\n", 
            "+                                    </hosts>\n", 
            "+                                    <domain>test2.synapse.domain</domain>\n", 
            "+                                </service>\n", 
            "+                            </services>\n", 
            "+                        </loadBalancerConfig>\n", 
            "+                    </serviceDynamicLoadbalance>\n", 
            "+                </endpoint>\n", 
            "+            </send>\n", 
            "+            <drop/>\n", 
            "+        </in>\n", 
            "+\n", 
            "+        <out>\n", 
            "+            <!-- Send the messages where they have been sent (i.e. implicit To EPR) -->\n", 
            "+            <send/>\n", 
            "+        </out>\n", 
            "+    </sequence>\n", 
            "+\n", 
            "+    <sequence name=\"errorHandler\">\n", 
            "+        <makefault response=\"true\">\n", 
            "+            <code xmlns:tns=\"http://www.w3.org/2003/05/soap-envelope\" value=\"tns:Receiver\"/>\n", 
            "+            <reason value=\"COULDN'T SEND THE MESSAGE TO THE SERVER.\"/>\n", 
            "+        </makefault>\n", 
            "+        <send/>\n", 
            "+    </sequence>\n", 
            "+\n", 
            "+</definitions>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/sample/synapse_sample_60.xml", 
      "from": "java/repository/conf/sample/synapse_sample_60.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,154", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.core.axis2;\n", 
            "+\n", 
            "+import org.apache.axis2.clustering.ClusteringAgent;\n", 
            "+import org.apache.axis2.clustering.Member;\n", 
            "+import org.apache.axis2.clustering.management.GroupManagementAgent;\n", 
            "+import org.apache.axis2.context.ConfigurationContext;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.core.LoadBalanceMembershipHandler;\n", 
            "+import org.apache.synapse.endpoints.DynamicLoadbalanceFaultHandler;\n", 
            "+import org.apache.synapse.endpoints.algorithms.AlgorithmContext;\n", 
            "+import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;\n", 
            "+\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Bridge between Axis2 membership notification and Synapse load balancing\n", 
            "+ */\n", 
            "+public class ServiceLoadBalanceMembershipHandler implements LoadBalanceMembershipHandler {\n", 
            "+    private static final Log log = LogFactory.getLog(ServiceLoadBalanceMembershipHandler.class);\n", 
            "+\n", 
            "+    private ConfigurationContext configCtx;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Key - Host, Value - DomainAlgorithmContext\n", 
            "+     */\n", 
            "+    private Map<String, DomainAlgorithmContext> hostDomainAlgorithmContextMap =\n", 
            "+                                    new HashMap<String, DomainAlgorithmContext>();\n", 
            "+    private ClusteringAgent clusteringAgent;\n", 
            "+\n", 
            "+    public ServiceLoadBalanceMembershipHandler(Map<String, String> hostDomainMap,\n", 
            "+                                               LoadbalanceAlgorithm algorithm,\n", 
            "+                                               ConfigurationContext configCtx,\n", 
            "+                                               boolean isClusteringEnabled,\n", 
            "+                                               String endpointName) {\n", 
            "+        for (Map.Entry<String, String> entry : hostDomainMap.entrySet()) {\n", 
            "+            AlgorithmContext algorithmContext =\n", 
            "+                new AlgorithmContext(isClusteringEnabled, configCtx, endpointName + \".\" + entry.getKey());\n", 
            "+            this.hostDomainAlgorithmContextMap.put(entry.getKey(),\n", 
            "+                                   new DomainAlgorithmContext(entry.getValue(), algorithm.clone(), algorithmContext));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void init(Properties props, LoadbalanceAlgorithm algorithm) {\n", 
            "+        // Nothing to do\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setConfigurationContext(ConfigurationContext configCtx) {\n", 
            "+        this.configCtx = configCtx;\n", 
            "+\n", 
            "+        // The following code does the bridging between Axis2 and Synapse load balancing\n", 
            "+        clusteringAgent = configCtx.getAxisConfiguration().getClusteringAgent();\n", 
            "+        if(clusteringAgent == null){\n", 
            "+            String msg = \"In order to enable load balancing across an Axis2 cluster, \" +\n", 
            "+                         \"the cluster entry should be enabled in the axis2.xml file\";\n", 
            "+            log.error(msg);\n", 
            "+            throw new SynapseException(msg);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public ConfigurationContext getConfigurationContext(){\n", 
            "+        return configCtx;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Getting the next member to which the request has to be sent in a round-robin fashion\n", 
            "+     *\n", 
            "+     * @param context The AlgorithmContext\n", 
            "+     * @return The current member\n", 
            "+     * @deprecated Use {@link #getNextApplicationMember(String)}\n", 
            "+     */\n", 
            "+    public Member getNextApplicationMember(AlgorithmContext context) {\n", 
            "+        throw new UnsupportedOperationException(\"This operation is invalid. \" +\n", 
            "+                                                \"Call getNextApplicationMember(String host)\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public Member getNextApplicationMember(String host) {\n", 
            "+        DomainAlgorithmContext domainAlgorithmContext = hostDomainAlgorithmContextMap.get(host);\n", 
            "+        if(domainAlgorithmContext == null) {\n", 
            "+            throw new SynapseException(\"Domain not found for host\" + host);\n", 
            "+        }\n", 
            "+        String lbDomain = domainAlgorithmContext.getDomain();\n", 
            "+        LoadbalanceAlgorithm algorithm = domainAlgorithmContext.getAlgorithm();\n", 
            "+        GroupManagementAgent groupMgtAgent = clusteringAgent.getGroupManagementAgent(lbDomain);\n", 
            "+        if(groupMgtAgent == null){\n", 
            "+            String msg =\n", 
            "+                    \"A LoadBalanceEventHandler has not been specified in the axis2.xml \" +\n", 
            "+                    \"file for the domain \" + lbDomain + \" for host \" + host;\n", 
            "+            log.error(msg);\n", 
            "+            throw new SynapseException(msg);\n", 
            "+        }\n", 
            "+        algorithm.setApplicationMembers(groupMgtAgent.getMembers());\n", 
            "+        AlgorithmContext context = domainAlgorithmContext.getAlgorithmContext();\n", 
            "+        return algorithm.getNextApplicationMember(context);\n", 
            "+    }\n", 
            "+\n", 
            "+    public LoadbalanceAlgorithm getLoadbalanceAlgorithm() {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Properties getProperties() {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * POJO for maintaining the domain & AlgorithmContext for a particular host\n", 
            "+     */\n", 
            "+    private static class DomainAlgorithmContext {\n", 
            "+        // The clustering domain\n", 
            "+        private String domain;\n", 
            "+        private AlgorithmContext algorithmContext;\n", 
            "+        private LoadbalanceAlgorithm algorithm;\n", 
            "+\n", 
            "+        private DomainAlgorithmContext(String domain, LoadbalanceAlgorithm algorithm,\n", 
            "+                                       AlgorithmContext algorithmContext) {\n", 
            "+            this.domain = domain;\n", 
            "+            this.algorithm = algorithm;\n", 
            "+            this.algorithmContext = algorithmContext;\n", 
            "+        }\n", 
            "+\n", 
            "+        public LoadbalanceAlgorithm getAlgorithm() {\n", 
            "+            return algorithm;\n", 
            "+        }\n", 
            "+\n", 
            "+        public String getDomain() {\n", 
            "+            return domain;\n", 
            "+        }\n", 
            "+\n", 
            "+        public AlgorithmContext getAlgorithmContext() {\n", 
            "+            return algorithmContext;\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/ServiceLoadBalanceMembershipHandler.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/ServiceLoadBalanceMembershipHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-40,7 +40,13", 
          "lines": [
            " \n", 
            " import java.net.MalformedURLException;\n", 
            " import java.net.URL;\n", 
            "-import java.util.*;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Properties;\n", 
            "+import java.util.Set;\n", 
            "+import java.util.UUID;\n", 
            " \n", 
            " /**\n", 
            "  * Represents a dynamic load balance endpoint. The application membership is not static,\n"
          ]
        }, 
        {
          "locn": "-106,7 +112,6", 
          "lines": [
            "     public void send(MessageContext synCtx) {\n", 
            "         SessionInformation sessionInformation = null;\n", 
            "         Member currentMember = null;\n", 
            "-        //TODO Temp hack: ESB removes the session id from request in a random manner.\n", 
            "         setCookieHeader(synCtx);\n", 
            " \n", 
            "         ConfigurationContext configCtx =\n"
          ]
        }, 
        {
          "locn": "-145,8 +150,6", 
          "lines": [
            "             }\n", 
            " \n", 
            "         }\n", 
            "-\n", 
            "-        setupTransportHeaders(synCtx);\n", 
            "         DynamicLoadbalanceFaultHandlerImpl faultHandler = new DynamicLoadbalanceFaultHandlerImpl();\n", 
            "         if (sessionInformation != null && currentMember != null) {\n", 
            "             //send message on current session\n"
          ]
        }, 
        {
          "locn": "-209,37 +212,6", 
          "lines": [
            "         return null;\n", 
            "     }\n", 
            " \n", 
            "-    /**\n", 
            "-     * Adds the X-Forwarded-For header to the outgoing message.\n", 
            "-     *\n", 
            "-     * @param synCtx Current message context\n", 
            "-     */\n", 
            "-\tprotected void setupTransportHeaders(MessageContext synCtx) {\n", 
            "-\t\tAxis2MessageContext axis2smc = (Axis2MessageContext) synCtx;\n", 
            "-        org.apache.axis2.context.MessageContext axis2MessageCtx =\n", 
            "-                axis2smc.getAxis2MessageContext();\n", 
            "-        Object headers = axis2MessageCtx.getProperty(\n", 
            "-                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "-        if (headers != null && headers instanceof Map ) {\n", 
            "-        \tMap headersMap = (Map) headers;\n", 
            "-        \tString xForwardFor = (String) headersMap.get(NhttpConstants.HEADER_X_FORWARDED_FOR);\n", 
            "-        \tString remoteHost = (String) axis2MessageCtx.getProperty(\n", 
            "-                    org.apache.axis2.context.MessageContext.REMOTE_ADDR);\n", 
            "-\n", 
            "-            if (xForwardFor != null && !\"\".equals(xForwardFor)) {\n", 
            "-                StringBuilder xForwardedForString = new StringBuilder();\n", 
            "-                xForwardedForString.append(xForwardFor);\n", 
            "-                if (remoteHost != null && !\"\".equals(remoteHost)) {\n", 
            "-                    xForwardedForString.append(\",\").append(remoteHost);\n", 
            "-                }\n", 
            "-                headersMap.put(NhttpConstants.HEADER_X_FORWARDED_FOR, xForwardedForString.toString());\n", 
            "-            } else {\n", 
            "-                headersMap.put(NhttpConstants.HEADER_X_FORWARDED_FOR,remoteHost);\n", 
            "-            }\n", 
            "-\n", 
            "-        }\n", 
            "-\t}\n", 
            "-\n", 
            "     public void setName(String name) {\n", 
            "         super.setName(name);\n", 
            " //        algorithmContext.setContextID(name);\n"
          ]
        }, 
        {
          "locn": "-310,8 +282,7", 
          "lines": [
            "         }\n", 
            " \n", 
            "         Map<String, String> memberHosts;\n", 
            "-        if ((memberHosts = (Map<String, String>) currentMember.getProperties().get(\n", 
            "-                HttpSessionDispatcher.HOSTS)) == null) {\n", 
            "+        if ((memberHosts = (Map<String, String>) currentMember.getProperties().get(HttpSessionDispatcher.HOSTS)) == null) {\n", 
            "             currentMember.getProperties().put(HttpSessionDispatcher.HOSTS,\n", 
            "                     memberHosts = new HashMap<String, String>());\n", 
            "         }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,280", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.endpoints;\n", 
            "+\n", 
            "+import org.apache.axis2.addressing.EndpointReference;\n", 
            "+import org.apache.axis2.clustering.ClusteringAgent;\n", 
            "+import org.apache.axis2.clustering.Member;\n", 
            "+import org.apache.axis2.clustering.management.DefaultGroupManagementAgent;\n", 
            "+import org.apache.axis2.context.ConfigurationContext;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.core.LoadBalanceMembershipHandler;\n", 
            "+import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.ServiceLoadBalanceMembershipHandler;\n", 
            "+import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;\n", 
            "+import org.apache.synapse.endpoints.dispatch.SALSessions;\n", 
            "+import org.apache.synapse.endpoints.dispatch.SessionInformation;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "+\n", 
            "+import java.util.Collections;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Set;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Represents a dynamic load balance endpoint. The application membership is not static,\n", 
            "+ * but discovered through some mechanism such as using a GCF\n", 
            "+ */\n", 
            "+public class ServiceDynamicLoadbalanceEndpoint extends DynamicLoadbalanceEndpoint {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(ServiceDynamicLoadbalanceEndpoint.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Axis2 based membership handler which handles members in multiple clustering domains\n", 
            "+     */\n", 
            "+    private ServiceLoadBalanceMembershipHandler slbMembershipHandler;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Key - host, Value - domain\n", 
            "+     */\n", 
            "+    private Map<String, String> hostDomainMap;\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void init(SynapseEnvironment synapseEnvironment) {\n", 
            "+        if (!initialized) {\n", 
            "+            super.init(synapseEnvironment);\n", 
            "+            ConfigurationContext cfgCtx =\n", 
            "+                    ((Axis2SynapseEnvironment) synapseEnvironment).getAxis2ConfigurationContext();\n", 
            "+            ClusteringAgent clusteringAgent = cfgCtx.getAxisConfiguration().getClusteringAgent();\n", 
            "+            if (clusteringAgent == null) {\n", 
            "+                throw new SynapseException(\"Axis2 ClusteringAgent not defined in axis2.xml\");\n", 
            "+            }\n", 
            "+            // Add the Axis2 GroupManagement agents\n", 
            "+            for (String domain : hostDomainMap.values()) {\n", 
            "+                if (clusteringAgent.getGroupManagementAgent(domain) == null) {\n", 
            "+                    clusteringAgent.addGroupManagementAgent(new DefaultGroupManagementAgent(), domain);\n", 
            "+                }\n", 
            "+            }\n", 
            "+            slbMembershipHandler = new ServiceLoadBalanceMembershipHandler(hostDomainMap,\n", 
            "+                                                                           getAlgorithm(),\n", 
            "+                                                                           cfgCtx,\n", 
            "+                                                                           isClusteringEnabled,\n", 
            "+                                                                           getName());\n", 
            "+\n", 
            "+            // Initialize the SAL Sessions if already has not been initialized.\n", 
            "+            SALSessions salSessions = SALSessions.getInstance();\n", 
            "+            if (!salSessions.isInitialized()) {\n", 
            "+                salSessions.initialize(isClusteringEnabled, cfgCtx);\n", 
            "+            }\n", 
            "+            initialized = true;\n", 
            "+            log.info(\"ServiceDynamicLoadbalanceEndpoint initialized\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public ServiceDynamicLoadbalanceEndpoint(Map<String, String> hostDomainMap,\n", 
            "+                                             LoadbalanceAlgorithm algorithm) {\n", 
            "+\n", 
            "+        this.hostDomainMap = hostDomainMap;\n", 
            "+        setAlgorithm(algorithm);\n", 
            "+    }\n", 
            "+\n", 
            "+    public LoadBalanceMembershipHandler getLbMembershipHandler() {\n", 
            "+        return slbMembershipHandler;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Map<String, String> getHostDomainMap() {\n", 
            "+        return Collections.unmodifiableMap(hostDomainMap);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void send(MessageContext synCtx) {\n", 
            "+        setCookieHeader(synCtx);\n", 
            "+        //TODO: Refactor Session Aware LB dispatching code\n", 
            "+\n", 
            "+        // Check whether a valid session for session aware dispatching is available\n", 
            "+        Member currentMember = null;\n", 
            "+        SessionInformation sessionInformation = null;\n", 
            "+        if (isSessionAffinityBasedLB()) {\n", 
            "+            // first check if this session is associated with a session. if so, get the endpoint\n", 
            "+            // associated for that session.\n", 
            "+            sessionInformation =\n", 
            "+                    (SessionInformation) synCtx.getProperty(\n", 
            "+                            SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);\n", 
            "+\n", 
            "+            currentMember = (Member) synCtx.getProperty(\n", 
            "+                    SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);\n", 
            "+\n", 
            "+            if (sessionInformation == null && currentMember == null) {\n", 
            "+                sessionInformation = dispatcher.getSession(synCtx);\n", 
            "+                if (sessionInformation != null) {\n", 
            "+\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Current session id : \" + sessionInformation.getId());\n", 
            "+                    }\n", 
            "+\n", 
            "+                    currentMember = sessionInformation.getMember();\n", 
            "+                    synCtx.setProperty(\n", 
            "+                            SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER, currentMember);\n", 
            "+                    // This is for reliably recovery any session information if while response is getting ,\n", 
            "+                    // session information has been removed by cleaner.\n", 
            "+                    // This will not be a cost as  session information a not heavy data structure\n", 
            "+                    synCtx.setProperty(\n", 
            "+                            SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION, sessionInformation);\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+\n", 
            "+        // Dispatch request the relevant member\n", 
            "+        String targetHost = getTargetHost(synCtx);\n", 
            "+        ConfigurationContext configCtx =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();\n", 
            "+        if (slbMembershipHandler.getConfigurationContext() == null) {\n", 
            "+            slbMembershipHandler.setConfigurationContext(configCtx);\n", 
            "+        }\n", 
            "+        ServiceDynamicLoadbalanceFaultHandlerImpl faultHandler = new ServiceDynamicLoadbalanceFaultHandlerImpl();\n", 
            "+        faultHandler.setHost(targetHost);\n", 
            "+        if (sessionInformation != null && currentMember != null) {\n", 
            "+            //send message on current session\n", 
            "+            sessionInformation.updateExpiryTime();\n", 
            "+            sendToApplicationMember(synCtx, currentMember, faultHandler, false);\n", 
            "+        } else {\n", 
            "+            // prepare for a new session\n", 
            "+            currentMember = slbMembershipHandler.getNextApplicationMember(targetHost);\n", 
            "+            if (currentMember == null) {\n", 
            "+                String msg = \"No application members available\";\n", 
            "+                log.error(msg);\n", 
            "+                throw new SynapseException(msg);\n", 
            "+            }\n", 
            "+            sendToApplicationMember(synCtx, currentMember, faultHandler, true);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getTargetHost(MessageContext synCtx) {\n", 
            "+        org.apache.axis2.context.MessageContext axis2MessageContext =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+        Map<String, String> headers =\n", 
            "+                (Map<String, String>) axis2MessageContext.\n", 
            "+                        getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        String address = headers.get(HTTP.TARGET_HOST);\n", 
            "+        synCtx.setProperty(\"LB_REQUEST_HOST\", address); // Need to set with the port\n", 
            "+        if (address.contains(\":\")) {\n", 
            "+            address = address.substring(0, address.indexOf(\":\"));\n", 
            "+        }\n", 
            "+        return address;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This FaultHandler will try to resend the message to another member if an error occurs\n", 
            "+     * while sending to some member. This is a failover mechanism\n", 
            "+     */\n", 
            "+    private class ServiceDynamicLoadbalanceFaultHandlerImpl extends DynamicLoadbalanceFaultHandler {\n", 
            "+\n", 
            "+        private EndpointReference to;\n", 
            "+        private Member currentMember;\n", 
            "+        private Endpoint currentEp;\n", 
            "+        private String host;\n", 
            "+\n", 
            "+        private static final int MAX_RETRY_COUNT = 5;\n", 
            "+\n", 
            "+        // ThreadLocal variable to keep track of how many times this fault handler has been\n", 
            "+        // called\n", 
            "+        private ThreadLocal<Integer> callCount = new ThreadLocal<Integer>() {\n", 
            "+            protected Integer initialValue() {\n", 
            "+                return 0;\n", 
            "+            }\n", 
            "+        };\n", 
            "+\n", 
            "+        public void setHost(String host) {\n", 
            "+            this.host = host;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void setCurrentMember(Member currentMember) {\n", 
            "+            this.currentMember = currentMember;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void setTo(EndpointReference to) {\n", 
            "+            this.to = to;\n", 
            "+        }\n", 
            "+\n", 
            "+        private ServiceDynamicLoadbalanceFaultHandlerImpl() {\n", 
            "+        }\n", 
            "+\n", 
            "+        public void onFault(MessageContext synCtx) {\n", 
            "+            if (currentMember == null) {\n", 
            "+                return;\n", 
            "+            }\n", 
            "+            currentMember.suspend(10000);     // TODO: Make this configurable.\n", 
            "+            log.info(\"Suspended member \" + currentMember + \" for 10s\");\n", 
            "+\n", 
            "+            // Prevent infinite retrying to failed members\n", 
            "+            callCount.set(callCount.get() + 1);\n", 
            "+            if (callCount.get() >= MAX_RETRY_COUNT) {\n", 
            "+                return;\n", 
            "+            }\n", 
            "+\n", 
            "+            //cleanup endpoint if exists\n", 
            "+            if (currentEp != null) {\n", 
            "+                currentEp.destroy();\n", 
            "+            }\n", 
            "+            Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);\n", 
            "+            if (errorCode != null) {\n", 
            "+                if (errorCode.equals(NhttpConstants.CONNECTION_FAILED) ||\n", 
            "+                    errorCode.equals(NhttpConstants.CONNECT_CANCEL) ||\n", 
            "+                    errorCode.equals(NhttpConstants.CONNECT_TIMEOUT)) {\n", 
            "+                    // Try to resend to another member\n", 
            "+                    Member newMember = slbMembershipHandler.getNextApplicationMember(host);\n", 
            "+                    if (newMember == null) {\n", 
            "+                        String msg = \"No application members available\";\n", 
            "+                        log.error(msg);\n", 
            "+                        throw new SynapseException(msg);\n", 
            "+                    }\n", 
            "+                    log.info(\"Failed over to \" + newMember);\n", 
            "+                    synCtx.setTo(to);\n", 
            "+                    if (isSessionAffinityBasedLB()) {\n", 
            "+                        //We are sending the this message on a new session,\n", 
            "+                        // hence we need to remove previous session information\n", 
            "+                        Set pros = synCtx.getPropertyKeySet();\n", 
            "+                        if (pros != null) {\n", 
            "+                            pros.remove(SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                    try {\n", 
            "+                        Thread.sleep(1000);  // Sleep for sometime before retrying\n", 
            "+                    } catch (InterruptedException ignored) {\n", 
            "+                    }\n", 
            "+                    sendToApplicationMember(synCtx, newMember, this, true);\n", 
            "+                } else if (errorCode.equals(NhttpConstants.SND_IO_ERROR_SENDING) ||\n", 
            "+                           errorCode.equals(NhttpConstants.CONNECTION_CLOSED)) {\n", 
            "+                    // TODO: Envelope is consumed\n", 
            "+                }\n", 
            "+            }\n", 
            "+            // We cannot failover since we are using binary relay\n", 
            "+        }\n", 
            "+\n", 
            "+        public void setCurrentEp(Endpoint currentEp) {\n", 
            "+            this.currentEp = currentEp;\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/ServiceDynamicLoadbalanceEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/ServiceDynamicLoadbalanceEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-227,6 +227,12", 
          "lines": [
            "             return DynamicLoadbalanceEndpointFactory.getInstance();\n", 
            "         }\n", 
            " \n", 
            "+        OMElement sdlbElement = configElement.getFirstChildWithName\n", 
            "+                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"serviceDynamicLoadbalance\"));\n", 
            "+        if (sdlbElement != null) {\n", 
            "+            return ServiceDynamicLoadbalanceEndpointFactory.getInstance();\n", 
            "+        }\n", 
            "+        \n", 
            "         OMElement foElement = configElement.getFirstChildWithName\n", 
            "                 (new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"failover\"));\n", 
            "         if (foElement != null) {\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,212", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.config.xml.endpoints;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.impl.builder.StAXOMBuilder;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.config.xml.XMLConfigConstants;\n", 
            "+import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;\n", 
            "+import org.apache.synapse.endpoints.Endpoint;\n", 
            "+import org.apache.synapse.endpoints.ServiceDynamicLoadbalanceEndpoint;\n", 
            "+import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;\n", 
            "+import org.apache.synapse.endpoints.dispatch.Dispatcher;\n", 
            "+import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;\n", 
            "+import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.net.URL;\n", 
            "+import java.util.*;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Creates {@link org.apache.synapse.endpoints.DynamicLoadbalanceEndpoint} using an XML configuration.\n", 
            "+ * <p/>\n", 
            "+ * <pre>\n", 
            "+ * <endpoint name=\"sdLB\">\n", 
            "+ *       <serviceDynamicLoadbalance algorithm=\"org.apache.synapse.endpoints.algorithms.RoundRobin\"\n", 
            "+ *                                  configuration=\"file:repository/conf/lbservices.xml\"/>\n", 
            "+ * </endpoint>\n", 
            "+ * </pre>\n", 
            "+ * <p/>\n", 
            "+ * The configuration file has the following format. This can be even specified inline\n", 
            "+ * <loadBalancerConfig>\n", 
            "+ * <services>\n", 
            "+ * <service>\n", 
            "+ * <hosts>\n", 
            "+ * <host>test1.synapse.apache.org</host>\n", 
            "+ * <host>test1.apache.org</host>\n", 
            "+ * </hosts>\n", 
            "+ * <domain>test1.synapse.apache.domain</domain>\n", 
            "+ * </service>\n", 
            "+ * <service>\n", 
            "+ * <hosts>\n", 
            "+ * <host>test2.synapse.apache.org</host>\n", 
            "+ * <host>test2.apache.org</host>\n", 
            "+ * </hosts>\n", 
            "+ * <domain>test2.synapse.apache.domain</domain>\n", 
            "+ * </service>\n", 
            "+ * </services>\n", 
            "+ * </loadBalancerConfig>\n", 
            "+ */\n", 
            "+public class ServiceDynamicLoadbalanceEndpointFactory extends EndpointFactory {\n", 
            "+\n", 
            "+    private static ServiceDynamicLoadbalanceEndpointFactory instance =\n", 
            "+            new ServiceDynamicLoadbalanceEndpointFactory();\n", 
            "+    public static final QName SERVICES_QNAME = new QName(SynapseConstants.SYNAPSE_NAMESPACE,\n", 
            "+                                                         \"services\");\n", 
            "+    public static final QName LB_CONFIG_QNAME = new QName(SynapseConstants.SYNAPSE_NAMESPACE,\n", 
            "+                                                          \"loadBalancerConfig\");\n", 
            "+\n", 
            "+    private ServiceDynamicLoadbalanceEndpointFactory() {\n", 
            "+    }\n", 
            "+\n", 
            "+    public static ServiceDynamicLoadbalanceEndpointFactory getInstance() {\n", 
            "+        return instance;\n", 
            "+    }\n", 
            "+\n", 
            "+    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint,\n", 
            "+                                      Properties properties) {\n", 
            "+\n", 
            "+        OMElement loadbalanceElement =\n", 
            "+                epConfig.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,\n", 
            "+                                                         \"serviceDynamicLoadbalance\"));\n", 
            "+        if (loadbalanceElement == null) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+\n", 
            "+        String configuration =\n", 
            "+                loadbalanceElement.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,\n", 
            "+                                                               \"configuration\"));\n", 
            "+        OMElement servicesEle;\n", 
            "+        if (configuration != null) {\n", 
            "+            if (configuration.startsWith(\"$system:\")) {\n", 
            "+                configuration = System.getProperty(configuration.substring(\"$system:\".length()));\n", 
            "+            }\n", 
            "+            // Load the file\n", 
            "+            StAXOMBuilder builder = null;\n", 
            "+            try {\n", 
            "+                builder = new StAXOMBuilder(new URL(configuration).openStream());\n", 
            "+            } catch (Exception e) {\n", 
            "+                handleException(\"Could not load ServiceDynamicLoadbalanceEndpoint configuration file \" +\n", 
            "+                                configuration);\n", 
            "+            }\n", 
            "+            servicesEle = builder.getDocumentElement().getFirstChildWithName(SERVICES_QNAME);\n", 
            "+        } else {\n", 
            "+            OMElement lbConfigEle = loadbalanceElement.getFirstChildWithName(LB_CONFIG_QNAME);\n", 
            "+            if (lbConfigEle == null) {\n", 
            "+                throw new RuntimeException(\"loadBalancerConfig element not found as a child of \" +\n", 
            "+                                           \"serviceDynamicLoadbalance element\");\n", 
            "+            }\n", 
            "+            servicesEle = lbConfigEle.getFirstChildWithName(SERVICES_QNAME);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (servicesEle == null) {\n", 
            "+            throw new RuntimeException(\"services element not found in serviceDynamicLoadbalance configuration\");\n", 
            "+        }\n", 
            "+        Map<String, String> hostDomainMap = new HashMap<String, String>();\n", 
            "+        for (Iterator<OMElement> iter = servicesEle.getChildrenWithLocalName(\"service\"); iter.hasNext();) {\n", 
            "+            OMElement serviceEle = iter.next();\n", 
            "+            OMElement hostsEle =\n", 
            "+                    serviceEle.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"hosts\"));\n", 
            "+            if (hostsEle == null) {\n", 
            "+                throw new RuntimeException(\"hosts element not found as a child of service element\");\n", 
            "+            }\n", 
            "+            List<String> hosts = new ArrayList<String>();\n", 
            "+            for (Iterator<OMElement> hostIter = hostsEle.getChildrenWithLocalName(\"host\");\n", 
            "+                 hostIter.hasNext();) {\n", 
            "+                OMElement hostEle = hostIter.next();\n", 
            "+                String host = hostEle.getText();\n", 
            "+                if (host.trim().length() == 0) {\n", 
            "+                    throw new RuntimeException(\"host cannot be null\");\n", 
            "+                }\n", 
            "+                hosts.add(host);\n", 
            "+            }\n", 
            "+            OMElement domainEle =\n", 
            "+                    serviceEle.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,\n", 
            "+                                                               \"domain\"));\n", 
            "+            if (domainEle == null) {\n", 
            "+                throw new RuntimeException(\"domain element not found in as a child of services\");\n", 
            "+            }\n", 
            "+            String domain = domainEle.getText();\n", 
            "+            if (domain.trim().length() == 0) {\n", 
            "+                throw new RuntimeException(\"domain cannot be null\");\n", 
            "+            }\n", 
            "+            for (String host : hosts) {\n", 
            "+                if (hostDomainMap.containsKey(host)) {\n", 
            "+                    throw new RuntimeException(\"host \" + host + \" has been already defined for \" +\n", 
            "+                                               \"clustering domain \" + hostDomainMap.get(host));\n", 
            "+                }\n", 
            "+                hostDomainMap.put(host, domain);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if (hostDomainMap.isEmpty()) {\n", 
            "+            throw new RuntimeException(\"No service elements defined under services\");\n", 
            "+        }\n", 
            "+\n", 
            "+        LoadbalanceAlgorithm algorithm =\n", 
            "+                LoadbalanceAlgorithmFactory.\n", 
            "+                        createLoadbalanceAlgorithm(loadbalanceElement, null);\n", 
            "+\n", 
            "+        ServiceDynamicLoadbalanceEndpoint loadbalanceEndpoint =\n", 
            "+                new ServiceDynamicLoadbalanceEndpoint(hostDomainMap, algorithm);\n", 
            "+\n", 
            "+        // set endpoint name\n", 
            "+        OMAttribute name =\n", 
            "+                epConfig.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, \"name\"));\n", 
            "+        if (name != null) {\n", 
            "+            loadbalanceEndpoint.setName(name.getAttributeValue());\n", 
            "+        }\n", 
            "+\n", 
            "+        // get the session for this endpoint\n", 
            "+        OMElement sessionElement =\n", 
            "+                epConfig.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"session\"));\n", 
            "+        if (sessionElement != null) {\n", 
            "+\n", 
            "+            OMElement sessionTimeout = sessionElement.getFirstChildWithName(\n", 
            "+                    new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"sessionTimeout\"));\n", 
            "+\n", 
            "+            if (sessionTimeout != null) {\n", 
            "+                try {\n", 
            "+                    loadbalanceEndpoint.setSessionTimeout(Long.parseLong(\n", 
            "+                            sessionTimeout.getText().trim()));\n", 
            "+                } catch (NumberFormatException nfe) {\n", 
            "+                    handleException(\"Invalid session timeout value : \" + sessionTimeout.getText());\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            String type = sessionElement.getAttributeValue(new QName(\"type\"));\n", 
            "+\n", 
            "+            if (type.equalsIgnoreCase(\"soap\")) {\n", 
            "+                Dispatcher soapDispatcher = new SoapSessionDispatcher();\n", 
            "+                loadbalanceEndpoint.setDispatcher(soapDispatcher);\n", 
            "+\n", 
            "+            } else if (type.equalsIgnoreCase(\"http\")) {\n", 
            "+                Dispatcher httpDispatcher = new HttpSessionDispatcher();\n", 
            "+                loadbalanceEndpoint.setDispatcher(httpDispatcher);\n", 
            "+\n", 
            "+            }\n", 
            "+\n", 
            "+            loadbalanceEndpoint.setSessionAffinity(true);\n", 
            "+        }\n", 
            "+        loadbalanceEndpoint.setFailover(false);\n", 
            "+\n", 
            "+        return loadbalanceEndpoint;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/ServiceDynamicLoadbalanceEndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/ServiceDynamicLoadbalanceEndpointFactory.java"
    }
  ], 
  "id": "1210832"
}