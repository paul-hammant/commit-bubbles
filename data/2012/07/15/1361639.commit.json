{
  "when": "2012-07-15T03:17:49-04:00", 
  "message": "SYNAPSE-838: Introducing Bean and EJB mediators.\n", 
  "who": "sadeep", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-36,6 +36,8", 
          "lines": [
            " import org.apache.commons.io.FilenameUtils;\r\n", 
            " import org.apache.commons.logging.Log;\r\n", 
            " import org.apache.commons.logging.LogFactory;\r\n", 
            "+import org.apache.synapse.commons.beanstalk.enterprise.EnterpriseBeanstalkConstants;\r\n", 
            "+import org.apache.synapse.commons.beanstalk.enterprise.EnterpriseBeanstalkManager;\r\n", 
            " import org.apache.synapse.commons.datasource.DataSourceRepositoryHolder;\r\n", 
            " import org.apache.synapse.commons.snmp.SNMPConstants;\r\n", 
            " import org.apache.synapse.commons.snmp.SynapseSNMPAgent;\r\n"
          ]
        }, 
        {
          "locn": "-187,6 +189,7", 
          "lines": [
            "         deployMediatorExtensions();\r\n", 
            "         initDataSourceHelper(serverContextInformation);\r\n", 
            "         initSharedSecretCallbackHandlerCache(serverContextInformation);\r\n", 
            "+        initEnterpriseBeanstalkManager(serverContextInformation);\r\n", 
            "         initialized = true;\r\n", 
            "     }\r\n", 
            " \r\n"
          ]
        }, 
        {
          "locn": "-397,6 +400,15", 
          "lines": [
            "                 synapseTaskManager.cleanup();\r\n", 
            "             }\r\n", 
            " \r\n", 
            "+            // destroy beanstalks.\r\n", 
            "+            EnterpriseBeanstalkManager manager = (EnterpriseBeanstalkManager)\r\n", 
            "+                    serverContextInformation.getProperty(\r\n", 
            "+                            EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MANAGER_PROP_NAME);\r\n", 
            "+\r\n", 
            "+            if (manager != null) {\r\n", 
            "+                manager.destroy();\r\n", 
            "+            }\r\n", 
            "+\r\n", 
            "             // stop the listener manager\r\n", 
            "             if (listenerManager != null) {\r\n", 
            "                 listenerManager.stop();\r\n"
          ]
        }, 
        {
          "locn": "-864,6 +876,28", 
          "lines": [
            "         }\r\n", 
            "     }\r\n", 
            " \r\n", 
            "+    private synchronized void initEnterpriseBeanstalkManager(ServerContextInformation serverInfo) {\r\n", 
            "+\r\n", 
            "+        if (serverInfo.getProperty(\r\n", 
            "+                EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MANAGER_PROP_NAME) == null) {\r\n", 
            "+\r\n", 
            "+            EnterpriseBeanstalkManager beanstalkManager = new EnterpriseBeanstalkManager();\r\n", 
            "+\r\n", 
            "+            Object configProps = serverInfo.getProperty(\r\n", 
            "+                    EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_CONFIG_PROP_NAME);\r\n", 
            "+\r\n", 
            "+            if (configProps instanceof Properties) {\r\n", 
            "+                beanstalkManager.init((Properties) configProps);\r\n", 
            "+            } else {\r\n", 
            "+                Properties synapseProperties = SynapsePropertiesLoader.reloadSynapseProperties();\r\n", 
            "+                beanstalkManager.init(synapseProperties);\r\n", 
            "+            }\r\n", 
            "+            serverInfo.addProperty(\r\n", 
            "+                    EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MANAGER_PROP_NAME,\r\n", 
            "+                    beanstalkManager);\r\n", 
            "+        }\r\n", 
            "+    }\r\n", 
            "+\r\n", 
            "     private void addDefaultBuildersAndFormatters(AxisConfiguration axisConf) {\r\n", 
            "         if (axisConf.getMessageBuilder(\"text/plain\") == null) {\r\n", 
            "             axisConf.addMessageBuilder(\"text/plain\", new PlainTextBuilder());\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-19,8 +19,7", 
          "lines": [
            " \n", 
            " package org.apache.synapse.mediators;\n", 
            " \n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axiom.om.OMNamespace;\n", 
            "+import org.apache.axiom.om.*;\n", 
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            " import org.apache.synapse.MessageContext;\n"
          ]
        }, 
        {
          "locn": "-126,6 +125,38", 
          "lines": [
            " \n", 
            "     }\n", 
            " \n", 
            "+    public Object evaluateObjectValue(MessageContext synCtx) {\n", 
            "+        if (keyValue != null) {\n", 
            "+            return keyValue;\n", 
            "+        } else if (expression != null) {\n", 
            "+            return getObjectValue(synCtx);\n", 
            "+        } else {\n", 
            "+            handleException(\"Unable to resolve the value: \" + toString());\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private Object getObjectValue(MessageContext synCtx) {\n", 
            "+        try {\n", 
            "+            Object result = expression.selectSingleNode(synCtx);\n", 
            "+\n", 
            "+            if (result instanceof OMText) {\n", 
            "+                return ((OMText) result).getText();\n", 
            "+            } else if (result instanceof OMElement) {\n", 
            "+                return ((OMElement) result).getText();\n", 
            "+            } else if (result instanceof OMDocument) {\n", 
            "+                return ((OMDocument) result).getOMDocumentElement().toString();\n", 
            "+            } else if (result instanceof OMAttribute) {\n", 
            "+                return ((OMAttribute) result).getAttributeValue();\n", 
            "+            } else {\n", 
            "+                return result;\n", 
            "+            }\n", 
            "+        } catch (JaxenException e) {\n", 
            "+            handleException(\"Failed to evaluate the XPath expression: \" + expression, e);\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "     /**\n", 
            "      * Get the name of the value attribute\n", 
            "      *\n"
          ]
        }, 
        {
          "locn": "-145,6 +176,10", 
          "lines": [
            "         throw new SynapseException(msg);\n", 
            "     }\n", 
            " \n", 
            "+    private void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            " \n", 
            "     /**\n", 
            "      * checks whether key returned by #getKeyValue() is a string of an expression type.\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/Value.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/Value.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,41", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean.enterprise;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Defines constants used by EJB mediator configuration.\n", 
            "+ */\n", 
            "+public interface EJBConstants {\n", 
            "+\n", 
            "+    public static final String BEANSTALK = \"beanstalk\";\n", 
            "+\n", 
            "+    public static final String METHOD = \"method\";\n", 
            "+\n", 
            "+    public static final String SESSION_ID = \"sessionId\";\n", 
            "+\n", 
            "+    public static final String JNDI_NAME = \"jndiName\";\n", 
            "+\n", 
            "+    public static final String REMOVE = \"remove\";\n", 
            "+\n", 
            "+    public static final String ARGS = \"args\";\n", 
            "+\n", 
            "+    public static final String ARG = \"arg\";\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/enterprise/EJBConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/enterprise/EJBConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,235", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean.enterprise;\n", 
            "+\n", 
            "+import org.apache.synapse.ManagedLifecycle;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.commons.beanstalk.enterprise.EnterpriseBeanstalk;\n", 
            "+import org.apache.synapse.commons.beanstalk.enterprise.EnterpriseBeanstalkConstants;\n", 
            "+import org.apache.synapse.commons.beanstalk.enterprise.EnterpriseBeanstalkManager;\n", 
            "+import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.mediators.AbstractMediator;\n", 
            "+import org.apache.synapse.mediators.Value;\n", 
            "+import org.apache.synapse.mediators.bean.BeanUtils;\n", 
            "+import org.apache.synapse.mediators.bean.Target;\n", 
            "+\n", 
            "+import java.lang.reflect.Method;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+\n", 
            "+/**\n", 
            "+ * EJB mediator calls an external Enterprise JavaBean(EJB) and stores the result in the message\n", 
            "+ * payload or in a message context property.\n", 
            "+ * This mediator supports EJB3 Stateless and Stateful Session Beans.\n", 
            "+ */\n", 
            "+public class EJBMediator extends AbstractMediator implements ManagedLifecycle {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Name of the beanstalk to be used for this invocation.\n", 
            "+     */\n", 
            "+    private String beanstalkName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Fully qualified name of the remote interface of the EJB.\n", 
            "+     */\n", 
            "+    private String className;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Session id of the stateful session bean call, null for stateless session bean calls.\n", 
            "+     */\n", 
            "+    private Value sessionId;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Target to store the result of the EJB method call.\n", 
            "+     */\n", 
            "+    private Target target;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * JNDI name of the bean. Could be null if this bean is already cached in the beanstalk.\n", 
            "+     */\n", 
            "+    private String jndiName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Whether or not this bean is removed from the beanstalk after the method invocation.\n", 
            "+     */\n", 
            "+    private boolean remove;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Argument list for the remote method invocation.\n", 
            "+     */\n", 
            "+    private List<Value> argumentList = new ArrayList<Value>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * EnterpriseBeanstalk retrieved from the Synapse environment.\n", 
            "+     */\n", 
            "+    private volatile EnterpriseBeanstalk beanstalk;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Resolved method. This is inferred by looking at the method name and the argument count.\n", 
            "+     */\n", 
            "+    private volatile Method method;\n", 
            "+\n", 
            "+    /**\n", 
            "+     *\n", 
            "+     * @param se SynapseEnvironment to be used for initialization\n", 
            "+     */\n", 
            "+    public void init(SynapseEnvironment se) {\n", 
            "+\n", 
            "+        EnterpriseBeanstalkManager beanstalkManager =\n", 
            "+                (EnterpriseBeanstalkManager) se.getServerContextInformation().getProperty(\n", 
            "+                        EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MANAGER_PROP_NAME);\n", 
            "+\n", 
            "+        if (beanstalkManager == null) {\n", 
            "+            throw new SynapseException(\"Initialization failed. EnterpriseBeanstalkManager not \" +\n", 
            "+                    \"found.\");\n", 
            "+        }\n", 
            "+\n", 
            "+        beanstalk = beanstalkManager.getEnterpriseBeanstalk(beanstalkName);\n", 
            "+\n", 
            "+        if (beanstalk == null) {\n", 
            "+            throw new SynapseException(\"Initialization failed. '\" + beanstalkName +\n", 
            "+                    \"' beanstalk not found in EnterpriseBeanstalkManager.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Calls an external EJB according to the supplied semantics and attaches the result into the\n", 
            "+     * message/message context.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    public boolean mediate(MessageContext synCtx) {\n", 
            "+\n", 
            "+        Object ejb = beanstalk.getEnterpriseBean(\n", 
            "+                                    className,\n", 
            "+                                    sessionId == null ? null : sessionId.evaluateValue(synCtx),\n", 
            "+                                    jndiName);\n", 
            "+\n", 
            "+        if (ejb == null) {\n", 
            "+            handleException(\"EJB not found. class: \" + className + \", bean id: \" + sessionId +\n", 
            "+                    \", jndi name: \" + jndiName + \".\", synCtx);\n", 
            "+        }\n", 
            "+\n", 
            "+        Object result = null;\n", 
            "+        try {\n", 
            "+            result = BeanUtils.invokeInstanceMethod(ejb, method, buildArguments(synCtx));\n", 
            "+        } catch (SynapseException e) {\n", 
            "+            handleException(\"Failed to invoke method: \" + method + \" on EJB object of \" +\n", 
            "+                    \"type: \" + className + \".\", e, synCtx);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (target != null) {\n", 
            "+            target.insert(synCtx, result);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (remove) {\n", 
            "+            beanstalk.removeEnterpriseBean(className,\n", 
            "+                                sessionId == null ? null : sessionId.evaluateValue(synCtx));\n", 
            "+        }\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void destroy() {\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Builds the argument values using the current message context.\n", 
            "+     * @param synCtx Current message context\n", 
            "+     * @return Built argument list\n", 
            "+     */\n", 
            "+    private Object[] buildArguments(MessageContext synCtx) {\n", 
            "+\n", 
            "+        Object[] args = new Object[argumentList.size()];\n", 
            "+        for (int i = 0; i < args.length; ++i) {\n", 
            "+            args[i] = argumentList.get(i).evaluateObjectValue(synCtx);\n", 
            "+        }\n", 
            "+        return args;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    //-------------------------- Getters & Setters --------------------------//\n", 
            "+\n", 
            "+    public String getBeanstalkName() {\n", 
            "+        return beanstalkName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setBeanstalkName(String beanstalkName) {\n", 
            "+        this.beanstalkName = beanstalkName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getClassName() {\n", 
            "+        return className;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setClassName(String className) {\n", 
            "+        this.className = className;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Value getSessionId() {\n", 
            "+        return sessionId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setSessionId(Value sessionId) {\n", 
            "+        this.sessionId = sessionId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Method getMethod() {\n", 
            "+        return method;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setMethod(Method method) {\n", 
            "+        this.method = method;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Target getTarget() {\n", 
            "+        return target;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setTarget(Target target) {\n", 
            "+        this.target = target;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getJndiName() {\n", 
            "+        return jndiName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setJndiName(String jndiName) {\n", 
            "+        this.jndiName = jndiName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isRemove() {\n", 
            "+        return remove;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setRemove(boolean remove) {\n", 
            "+        this.remove = remove;\n", 
            "+    }\n", 
            "+\n", 
            "+    public List<Value> getArgumentList() {\n", 
            "+        return argumentList;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addArgument(Value argument) {\n", 
            "+        argumentList.add(argument);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/enterprise/EJBMediator.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/enterprise/EJBMediator.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,41", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Defines constants used by Bean mediator configuration.\n", 
            "+ */\n", 
            "+public interface BeanConstants {\n", 
            "+\n", 
            "+    public static final String ACTION = \"action\";\n", 
            "+\n", 
            "+    public static final String CLASS = \"class\";\n", 
            "+\n", 
            "+    public static final String VAR = \"var\";\n", 
            "+\n", 
            "+    public static final String REPLACE = \"replace\";\n", 
            "+\n", 
            "+    public static final String PROPERTY = \"property\";\n", 
            "+\n", 
            "+    public static final String VALUE = \"value\";\n", 
            "+\n", 
            "+    public static final String TARGET = \"target\";\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,121", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean;\n", 
            "+\n", 
            "+import org.apache.axiom.om.util.AXIOMUtil;\n", 
            "+import org.apache.axis2.databinding.typemapping.SimpleTypeMapper;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+\n", 
            "+import javax.xml.stream.XMLStreamException;\n", 
            "+import java.lang.reflect.InvocationTargetException;\n", 
            "+import java.lang.reflect.Method;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Provides utility methods for method invocation via reflection.\n", 
            "+ */\n", 
            "+public class BeanUtils {\n", 
            "+\n", 
            "+    private BeanUtils() {}\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Invokes the given method on the given object via reflection, handles simple type conversion\n", 
            "+     * from String to simple types.\n", 
            "+     * @param instance  Instance to invoke the method on.\n", 
            "+     * @param method    Method to be invoked.\n", 
            "+     * @param args      Arguments for the method invocation.\n", 
            "+     * @return          Return value of the method invocation.\n", 
            "+     * @throws SynapseException If method invocation fails.\n", 
            "+     */\n", 
            "+    public static Object invokeInstanceMethod(Object instance, Method method, Object[] args) throws\n", 
            "+                                                                                  SynapseException {\n", 
            "+        Class[] paramTypes = method.getParameterTypes();\n", 
            "+\n", 
            "+        if (paramTypes.length != args.length) {\n", 
            "+            throw new SynapseException(\"Provided argument count does not match method the \" +\n", 
            "+                    \"parameter count of method '\" + method.getName() + \"'. Argument count = \" +\n", 
            "+                    args.length + \", method parameter count = \" + paramTypes.length + \".\");\n", 
            "+        }\n", 
            "+\n", 
            "+        Object[] processedArgs = new Object[paramTypes.length];\n", 
            "+\n", 
            "+        for (int i = 0; i < paramTypes.length; ++i) {\n", 
            "+\n", 
            "+            if (args[i] == null || paramTypes[i].isAssignableFrom(args[i].getClass())) {\n", 
            "+                processedArgs[i] = args[i];\n", 
            "+            } else if (SimpleTypeMapper.isSimpleType(paramTypes[i])) {\n", 
            "+                try {\n", 
            "+                    // Workaround for https://issues.apache.org/jira/browse/AXIS2-5212\n", 
            "+                    processedArgs[i] = SimpleTypeMapper.getSimpleTypeObject(paramTypes[i],\n", 
            "+                            AXIOMUtil.stringToOM(\"<a>\" + args[i].toString() + \"</a>\"));\n", 
            "+                } catch (XMLStreamException ignored) {\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                throw new SynapseException(\"Incompatible argument found in argument \" + i +\n", 
            "+                        \" for '\" + method.getName() + \"' method.\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            return method.invoke(instance, processedArgs);\n", 
            "+        } catch (IllegalAccessException e) {\n", 
            "+            throw new SynapseException(\"Error while invoking '\" + method.getName() + \"' method \" +\n", 
            "+                    \"via reflection.\", e);\n", 
            "+        } catch (InvocationTargetException e) {\n", 
            "+            throw new SynapseException(\"Error while invoking '\" + method.getName() + \"' method \" +\n", 
            "+                    \"via reflection.\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Finds a method in the given class with the given method name and argument count. Fails to\n", 
            "+     * resolve the method if two or more overloaded methods are present with the given name and\n", 
            "+     * argument count.\n", 
            "+     *\n", 
            "+     * @param clazz      Class to search for the method in.\n", 
            "+     * @param methodName Method name to search for.\n", 
            "+     * @param argCount   Length of the argument list.\n", 
            "+     * @return           The resolved method, or null if no matching method is found.\n", 
            "+     * @throws SynapseException If two or more overloaded methods are found with the given name and\n", 
            "+     * argument count.\n", 
            "+     */\n", 
            "+    public static Method resolveMethod(Class clazz, String methodName, int argCount) throws\n", 
            "+                                                                                  SynapseException {\n", 
            "+        Method resolvedMethod = null;\n", 
            "+\n", 
            "+        for (Method method : clazz.getMethods()) {\n", 
            "+\n", 
            "+            if (method.getName().equals(methodName) &&\n", 
            "+                    method.getParameterTypes().length == argCount) {\n", 
            "+\n", 
            "+                if (resolvedMethod == null) {\n", 
            "+                    resolvedMethod = method;\n", 
            "+                } else {\n", 
            "+                    throw new SynapseException(\"More than one '\" + methodName + \"' methods \" +\n", 
            "+                            \"taking \" + argCount + \" arguments are found in '\" +\n", 
            "+                            clazz.getName() + \"' class.\");\n", 
            "+                }\n", 
            "+\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return resolvedMethod;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,113", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.OMText;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.config.xml.ValueFactory;\n", 
            "+import org.apache.synapse.config.xml.ValueSerializer;\n", 
            "+import org.apache.synapse.mediators.Value;\n", 
            "+import org.apache.synapse.util.xpath.SynapseXPath;\n", 
            "+import org.jaxen.JaxenException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Represents a Target of an action performed by a mediator. Handles both static property names and\n", 
            "+ * dynamic(XPath) keys.\n", 
            "+ */\n", 
            "+public class Target {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(Target.class);\n", 
            "+\n", 
            "+    private Value value;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Creates a new Target from the OMElement\n", 
            "+     * @param attributeName Name of the attribute where the property name/ XPath expression is\n", 
            "+     * stored.\n", 
            "+     * @param element OMElement where the the XPath expression and the namespaces are stored.\n", 
            "+     */\n", 
            "+    public Target(String attributeName, OMElement element) {\n", 
            "+        this.value = new ValueFactory().createValue(attributeName, element);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Inserts the given object into the target specified by the current Target object.\n", 
            "+     * @param synCtx Message Context to be enriched with the object.\n", 
            "+     * @param object Object to be inserted.\n", 
            "+     */\n", 
            "+    public void insert(MessageContext synCtx, Object object) {\n", 
            "+\n", 
            "+        if (value.getExpression() != null) {\n", 
            "+\n", 
            "+            SynapseXPath expression = value.getExpression();\n", 
            "+            Object targetObj = null;\n", 
            "+\n", 
            "+            try {\n", 
            "+                targetObj = expression.selectSingleNode(synCtx);\n", 
            "+            } catch (JaxenException e) {\n", 
            "+                handleException(\"Failed to select the target.\", e);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (targetObj instanceof OMText) {\n", 
            "+                Object targetParent = ((OMText) targetObj).getParent();\n", 
            "+                if (targetParent != null && targetParent instanceof OMElement) {\n", 
            "+                    ((OMElement) targetParent).setText(object == null ? \"\" : object.toString());\n", 
            "+                } else {\n", 
            "+                    handleException(\"Invalid target is specified by the expression: \" + expression);\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                handleException(\"Invalid target is specified by the expression: \" + expression);\n", 
            "+            }\n", 
            "+\n", 
            "+        } else if (value.getKeyValue() != null) {\n", 
            "+\n", 
            "+            synCtx.setProperty(value.getKeyValue(), object);\n", 
            "+\n", 
            "+        } else {\n", 
            "+\n", 
            "+            handleException(\"Invalid target description. \" + value);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Serialized this Target object into the given element with the given attribute name.\n", 
            "+     *\n", 
            "+     * @param attributeName Name of the attribute.\n", 
            "+     * @param element Element to serialize this target in to.\n", 
            "+     * @return Element after serializing this target.\n", 
            "+     */\n", 
            "+    public OMElement serializeTarget(String attributeName, OMElement element) {\n", 
            "+        return new ValueSerializer().serializeValue(value, attributeName, element);\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleException(String msg, Throwable e) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/Target.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/Target.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,311", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.mediators.bean;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.SynapseLog;\n", 
            "+import org.apache.synapse.mediators.AbstractMediator;\n", 
            "+import org.apache.synapse.mediators.Value;\n", 
            "+\n", 
            "+import java.beans.IntrospectionException;\n", 
            "+import java.beans.PropertyDescriptor;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Bean mediator can manipulate a JavaBean that is bound to the Synapse message context as a\n", 
            "+ * property.\n", 
            "+ * This mediator can be used to create a new bean (CREATE action), remove an existing bean\n", 
            "+ * (REMOVE action), set a property of an existing JavaBean (SET_PROPERTY action) or to retrieve a\n", 
            "+ * property of an existing JavaBean (GET_PROPERTY action). Classes of objects manipulated by this\n", 
            "+ * mediator must follow the JavaBeans naming conventions.\n", 
            "+ */\n", 
            "+public class BeanMediator extends AbstractMediator {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Action performed by this mediator.\n", 
            "+     */\n", 
            "+    private Action action;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Variable name. This corresponds to the property name using which the bean is attached to\n", 
            "+     * the message context\n", 
            "+     */\n", 
            "+    private String varName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Name of the bean property.\n", 
            "+     */\n", 
            "+    private String propertyName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Value for SET_PROPERTY action\n", 
            "+     */\n", 
            "+    private Value value;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Target for GET_PROPERTY action\n", 
            "+     */\n", 
            "+    private Target target;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Whether or not the existing bean is replaced by the CREATE action.\n", 
            "+     */\n", 
            "+    private boolean replace = true;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Class object representing the class of the bean\n", 
            "+     */\n", 
            "+    private Class clazz;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Manipulates a JavaBean attached to the current message context according to the supplied\n", 
            "+     * semantics.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    public boolean mediate(MessageContext synCtx) {\n", 
            "+\n", 
            "+        SynapseLog synLog = getLog(synCtx);\n", 
            "+\n", 
            "+        if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+            synLog.traceOrDebug(\"Start : Bean mediator\");\n", 
            "+\n", 
            "+            if (synLog.isTraceTraceEnabled()) {\n", 
            "+                synLog.traceTrace(\"Message : \" + synCtx.getEnvelope());\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        boolean output = false;\n", 
            "+\n", 
            "+        switch (action) {\n", 
            "+            case CREATE:\n", 
            "+                if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+                    synLog.traceOrDebug(\"Creating a new bean of type '\" + clazz.getName() +\n", 
            "+                            \"' with var name '\" + varName + \"'.\");\n", 
            "+                }\n", 
            "+                output = mediateCreateBeanAction(synCtx);\n", 
            "+                break;\n", 
            "+            case REMOVE:\n", 
            "+                if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+                    synLog.traceOrDebug(\"Removing the bean with var name '\" + varName + \"'.\");\n", 
            "+                }\n", 
            "+                output = mediateRemoveBeanAction(synCtx);\n", 
            "+                break;\n", 
            "+            case SET_PROPERTY:\n", 
            "+                if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+                    synLog.traceOrDebug(\"Setting '\" + propertyName + \"' property of the bean \" +\n", 
            "+                            \"with var name '\" + varName + \"'.\");\n", 
            "+                }\n", 
            "+                output = mediateSetPropertyAction(synCtx);\n", 
            "+                break;\n", 
            "+            case GET_PROPERTY:\n", 
            "+                if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+                    synLog.traceOrDebug(\"Retrieving '\" + propertyName + \"' property of the \" +\n", 
            "+                            \"bean with var name '\" + varName + \"'.\");\n", 
            "+                }\n", 
            "+                output = mediateGetPropertyAction(synCtx);\n", 
            "+                break;\n", 
            "+            default:\n", 
            "+                assert false;\n", 
            "+        }\n", 
            "+\n", 
            "+        if (synLog.isTraceOrDebugEnabled()) {\n", 
            "+            synLog.traceOrDebug(\"End : Bean mediator\");\n", 
            "+        }\n", 
            "+        return output;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Creates a new bean and attaches it to the current message context.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    private boolean mediateCreateBeanAction(MessageContext synCtx) {\n", 
            "+\n", 
            "+        if (!replace && synCtx.getProperty(varName) != null) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        Object instance = null;\n", 
            "+        try {\n", 
            "+            instance = clazz.newInstance();\n", 
            "+        } catch (Exception ex) {\n", 
            "+            handleException(\"An error occurred while instantiating '\" + clazz.getName() +\n", 
            "+                    \"' class.\", ex, synCtx);\n", 
            "+        }\n", 
            "+\n", 
            "+        synCtx.setProperty(varName, instance);\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Removes a bean attached to the current message context.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    private boolean mediateRemoveBeanAction(MessageContext synCtx) {\n", 
            "+\n", 
            "+        synCtx.getPropertyKeySet().remove(varName);\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Sets a property of a bean attached to the current message context.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    private boolean mediateSetPropertyAction(MessageContext synCtx) {\n", 
            "+\n", 
            "+        Object bean = synCtx.getProperty(varName);\n", 
            "+        if (bean == null) {\n", 
            "+            handleException(\"Bean with var name '\" + varName + \"' was not found.\", synCtx);\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+        Object valueObj = value.evaluateObjectValue(synCtx);\n", 
            "+\n", 
            "+        if (bean instanceof Map) {\n", 
            "+            ((Map) bean).put(propertyName, valueObj);\n", 
            "+        } else {\n", 
            "+            try {\n", 
            "+                BeanUtils.invokeInstanceMethod(\n", 
            "+                        bean,\n", 
            "+                        new PropertyDescriptor(propertyName, bean.getClass()).getWriteMethod(),\n", 
            "+                        new Object[]{valueObj}\n", 
            "+                );\n", 
            "+            } catch (IntrospectionException e) {\n", 
            "+                handleException(\"Could not resolve the setter method for '\" + propertyName +\n", 
            "+                        \"' property in '\" + bean.getClass() + \"'.\", e, synCtx);\n", 
            "+            } catch (SynapseException e) {\n", 
            "+                handleException(\"Error while invoking the setter method for '\" + propertyName +\n", 
            "+                        \"' property on '\" + bean.getClass() + \"'.\", e, synCtx);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Retrieves a property of a bean attached to the current message context.\n", 
            "+     * @param synCtx The current message for mediation\n", 
            "+     * @return true If mediation should continue\n", 
            "+     */\n", 
            "+    private boolean mediateGetPropertyAction(MessageContext synCtx) {\n", 
            "+\n", 
            "+        Object bean = synCtx.getProperty(varName);\n", 
            "+        if (bean == null) {\n", 
            "+            handleException(\"Bean with var name '\" + varName + \"' was not found.\", synCtx);\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+        Object value = null;\n", 
            "+\n", 
            "+        if (bean instanceof Map) {\n", 
            "+            value = ((Map) bean).get(propertyName);\n", 
            "+        } else {\n", 
            "+            try {\n", 
            "+                value = BeanUtils.invokeInstanceMethod(\n", 
            "+                            bean,\n", 
            "+                            new PropertyDescriptor(propertyName, bean.getClass()).getReadMethod(),\n", 
            "+                            new Object[0]\n", 
            "+                        );\n", 
            "+            } catch (IntrospectionException e) {\n", 
            "+                handleException(\"Could not resolve the getter method for '\" + propertyName +\n", 
            "+                        \"' property in '\" + bean.getClass() + \"'.\", e, synCtx);\n", 
            "+            } catch (SynapseException e) {\n", 
            "+                handleException(\"Error while invoking the getter method for '\" + propertyName +\n", 
            "+                        \"' property on '\" + bean.getClass() + \"'.\", e, synCtx);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            target.insert(synCtx, value);\n", 
            "+        } catch (SynapseException e) {\n", 
            "+            handleException(\"Failed to set the target after retrieving bean property.\", e,\n", 
            "+                    synCtx);\n", 
            "+        }\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Defines actions performed by Bean mediator.\n", 
            "+     */\n", 
            "+    public enum Action {\n", 
            "+        CREATE, REMOVE, SET_PROPERTY, GET_PROPERTY\n", 
            "+    }\n", 
            "+\n", 
            "+    //-------------------------- Getters & Setters --------------------------//\n", 
            "+\n", 
            "+    public Action getAction() {\n", 
            "+        return action;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setAction(Action action) {\n", 
            "+        this.action = action;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getVarName() {\n", 
            "+        return varName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setVarName(String varName) {\n", 
            "+        this.varName = varName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getPropertyName() {\n", 
            "+        return propertyName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setPropertyName(String propertyName) {\n", 
            "+        this.propertyName = propertyName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Value getValue() {\n", 
            "+        return value;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setValue(Value value) {\n", 
            "+        this.value = value;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Target getTarget() {\n", 
            "+        return target;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setTarget(Target target) {\n", 
            "+        this.target = target;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isReplace() {\n", 
            "+        return replace;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setReplace(boolean replace) {\n", 
            "+        this.replace = replace;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Class getClazz() {\n", 
            "+        return clazz;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setClazz(Class clazz) {\n", 
            "+        this.clazz = clazz;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanMediator.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/bean/BeanMediator.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,138", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.mediators.bean.BeanConstants;\n", 
            "+import org.apache.synapse.mediators.bean.BeanUtils;\n", 
            "+import org.apache.synapse.mediators.bean.Target;\n", 
            "+import org.apache.synapse.mediators.bean.enterprise.EJBConstants;\n", 
            "+import org.apache.synapse.mediators.bean.enterprise.EJBMediator;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.lang.reflect.Method;\n", 
            "+import java.util.Iterator;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Creates an {@link EJBMediator} from the provided XML configuration.\n", 
            "+ *\n", 
            "+ * <p/>\n", 
            "+ * <pre>\n", 
            "+ * &lt;ejb beanstalk=\"string\" class=\"string\" [sessionId=\"string\"] [remove=\"true | false\"]\n", 
            "+ * [method=\"string\"] [target=\"string | {xpath}\"] [jndiName=\"string\"] /&gt;\n", 
            "+ *   &lt;args&gt;\n", 
            "+ *     &lt;arg (value=\"string | {xpath}\")/&gt;*\n", 
            "+ *   &lt;/args&gt;\n", 
            "+ * &lt;/ejb&gt;\n", 
            "+ * </pre>\n", 
            "+ */\n", 
            "+public class EJBMediatorFactory extends AbstractMediatorFactory {\n", 
            "+\n", 
            "+    private static final QName EJB_Q =\n", 
            "+            new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, \"ejb\");\n", 
            "+\n", 
            "+    public Mediator createSpecificMediator(OMElement elem, Properties properties) {\n", 
            "+\n", 
            "+        EJBMediator mediator = new EJBMediator();\n", 
            "+\n", 
            "+        String attributeValue;\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(EJBConstants.BEANSTALK));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setBeanstalkName(attributeValue.trim());\n", 
            "+        } else {\n", 
            "+            handleException(\"'beanstalk' attribute of callEjb mediator is required\");\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.CLASS));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setClassName(attributeValue.trim());\n", 
            "+        } else {\n", 
            "+            handleException(\"'class' attribute of callEjb mediator is required\");\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(EJBConstants.SESSION_ID));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setSessionId(new ValueFactory().createValue(EJBConstants.SESSION_ID, elem));\n", 
            "+        }\n", 
            "+\n", 
            "+        boolean remove;\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(EJBConstants.REMOVE));\n", 
            "+        remove = Boolean.valueOf(attributeValue);\n", 
            "+        if (remove) {\n", 
            "+            mediator.setRemove(true);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (elem.getAttributeValue(new QName(BeanConstants.TARGET)) != null) {\n", 
            "+            mediator.setTarget(new Target(BeanConstants.TARGET, elem));\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(EJBConstants.JNDI_NAME));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setJndiName(attributeValue);\n", 
            "+        }\n", 
            "+\n", 
            "+        OMElement argumentsElem = elem.getFirstChildWithName(\n", 
            "+                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, EJBConstants.ARGS));\n", 
            "+\n", 
            "+        if (argumentsElem != null) {\n", 
            "+\n", 
            "+            Iterator itr = argumentsElem.getChildrenWithName(\n", 
            "+                    new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, EJBConstants.ARG));\n", 
            "+\n", 
            "+            while (itr.hasNext()) {\n", 
            "+                OMElement argElem = (OMElement) itr.next();\n", 
            "+\n", 
            "+                if (argElem.getAttributeValue(ATT_VALUE) != null) {\n", 
            "+                    mediator.addArgument(\n", 
            "+                            new ValueFactory().createValue(BeanConstants.VALUE, argElem));\n", 
            "+                } else {\n", 
            "+                    handleException(\"'value' attribute of 'arg' element is required.\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(EJBConstants.METHOD));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            Method method = null;\n", 
            "+            try {\n", 
            "+                method = BeanUtils.resolveMethod(\n", 
            "+                                        Class.forName(mediator.getClassName()),\n", 
            "+                                        attributeValue,\n", 
            "+                                        mediator.getArgumentList().size());\n", 
            "+            } catch (ClassNotFoundException e) {\n", 
            "+                handleException(\"Could not load '\" + mediator.getClassName() + \"' class.\", e);\n", 
            "+            }\n", 
            "+            mediator.setMethod(method);\n", 
            "+        } else if (!remove) {\n", 
            "+            handleException(\"'method' attribute of EJB mediator is optional only when it's a \" +\n", 
            "+                    \"bean removal.\");\n", 
            "+        }\n", 
            "+\n", 
            "+        return mediator;\n", 
            "+    }\n", 
            "+\n", 
            "+    public QName getTagQName() {\n", 
            "+        return EJB_Q;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EJBMediatorFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EJBMediatorFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,134", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.mediators.bean.BeanConstants;\n", 
            "+import org.apache.synapse.mediators.bean.BeanMediator;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Serializer for {@link BeanMediator} instances.\n", 
            "+ *\n", 
            "+ * @see BeanMediatorFactory\n", 
            "+ */\n", 
            "+public class BeanMediatorSerializer extends AbstractMediatorSerializer {\n", 
            "+\n", 
            "+    private static final String BEAN = \"bean\";\n", 
            "+\n", 
            "+    public OMElement serializeSpecificMediator(Mediator m) {\n", 
            "+\n", 
            "+        if (!(m instanceof BeanMediator)) {\n", 
            "+            handleException(\"Unsupported mediator was passed in for serialization: \" + m.getType());\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+\n", 
            "+        BeanMediator mediator = (BeanMediator) m;\n", 
            "+\n", 
            "+        OMElement mediatorElem = fac.createOMElement(BEAN, synNS);\n", 
            "+        saveTracingState(mediatorElem, mediator);\n", 
            "+\n", 
            "+        if (mediator.getAction() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.ACTION, nullNS, mediator.getAction().toString()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getVarName() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.VAR, nullNS, mediator.getVarName()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        switch (mediator.getAction()) {\n", 
            "+            case CREATE:\n", 
            "+                serializeCreateBeanCase(mediatorElem, mediator);\n", 
            "+                break;\n", 
            "+            case SET_PROPERTY:\n", 
            "+                serializeSetPropertyCase(mediatorElem, mediator);\n", 
            "+                break;\n", 
            "+            case GET_PROPERTY:\n", 
            "+                serializeGetPropertyCase(mediatorElem, mediator);\n", 
            "+                break;\n", 
            "+            default:\n", 
            "+                assert false;\n", 
            "+        }\n", 
            "+\n", 
            "+        return mediatorElem;\n", 
            "+    }\n", 
            "+\n", 
            "+    private void serializeCreateBeanCase(OMElement mediatorElem, BeanMediator mediator) {\n", 
            "+\n", 
            "+        if (mediator.getClazz() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.CLASS, nullNS, mediator.getClazz().getName()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!mediator.isReplace()) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.REPLACE, nullNS, Boolean.toString(false)));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void serializeSetPropertyCase(OMElement mediatorElem, BeanMediator mediator) {\n", 
            "+\n", 
            "+        serializePropertyName(mediatorElem, mediator);\n", 
            "+\n", 
            "+        if (mediator.getValue() != null) {\n", 
            "+            new ValueSerializer().serializeValue(\n", 
            "+                    mediator.getValue(), BeanConstants.VALUE, mediatorElem);\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void serializeGetPropertyCase(OMElement mediatorElem, BeanMediator mediator) {\n", 
            "+\n", 
            "+        serializePropertyName(mediatorElem, mediator);\n", 
            "+\n", 
            "+        if (mediator.getTarget() != null) {\n", 
            "+            mediator.getTarget().serializeTarget(BeanConstants.TARGET, mediatorElem);\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void serializePropertyName(OMElement mediatorElem, BeanMediator mediator) {\n", 
            "+\n", 
            "+        if (mediator.getPropertyName() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.PROPERTY, nullNS, mediator.getPropertyName()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getMediatorClassName() {\n", 
            "+        return BeanMediator.class.getName();\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleException() {\n", 
            "+        handleException(\"Invalid bean mediator was passed in for serialization\");\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/BeanMediatorSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/BeanMediatorSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,159", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.mediators.bean.BeanConstants;\n", 
            "+import org.apache.synapse.mediators.bean.BeanMediator;\n", 
            "+import org.apache.synapse.mediators.bean.Target;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Creates a {@link BeanMediator} from the provided XML configuration.\n", 
            "+ *\n", 
            "+ * <p/>\n", 
            "+ * <pre>\n", 
            "+ * &lt;bean action=&quot;CREATE | REMOVE | SET_PROPERTY | GET_PROPERTY&quot; var=&quot;string&quot;\n", 
            "+ * [class=&quot;string&quot;]  [property=&quot;string&quot;]\n", 
            "+ * [value=&quot;string | {xpath}&quot;] /&gt;\n", 
            "+ * </pre>\n", 
            "+ */\n", 
            "+public class BeanMediatorFactory extends AbstractMediatorFactory {\n", 
            "+\n", 
            "+    private static final QName BEAN_Q\n", 
            "+            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, \"bean\");\n", 
            "+\n", 
            "+    public Mediator createSpecificMediator(OMElement elem, Properties properties) {\n", 
            "+\n", 
            "+        BeanMediator mediator = new BeanMediator();\n", 
            "+\n", 
            "+        String attributeValue;\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.VAR));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setVarName(attributeValue);\n", 
            "+        } else {\n", 
            "+            handleException(\"'var' attribute of Bean mediator is required.\");\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.ACTION));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            try {\n", 
            "+                switch (BeanMediator.Action.valueOf(attributeValue.toUpperCase())) {\n", 
            "+                    case CREATE:\n", 
            "+                        populateCreateBeanCase(mediator, elem);\n", 
            "+                        break;\n", 
            "+                    case REMOVE:\n", 
            "+                        mediator.setAction(BeanMediator.Action.REMOVE);\n", 
            "+                        break;\n", 
            "+                    case SET_PROPERTY:\n", 
            "+                        populateSetPropertyCase(mediator, elem);\n", 
            "+                        break;\n", 
            "+                    case GET_PROPERTY:\n", 
            "+                        populateGetPropertyCase(mediator, elem);\n", 
            "+                        break;\n", 
            "+                    default:\n", 
            "+                        assert false;\n", 
            "+                }\n", 
            "+            } catch (IllegalArgumentException e) {\n", 
            "+                handleException(\"'action' attribute of bean mediator must be set to 'CREATE', \" +\n", 
            "+                        \"'REMOVE', 'SET_PROPERTY' or 'GET_PROPERTY'.\");\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            handleException(\"'action' attribute of Bean mediator is required.\");\n", 
            "+        }\n", 
            "+\n", 
            "+        return mediator;\n", 
            "+    }\n", 
            "+\n", 
            "+    private void populateCreateBeanCase(BeanMediator mediator, OMElement elem) {\n", 
            "+\n", 
            "+        mediator.setAction(BeanMediator.Action.CREATE);\n", 
            "+\n", 
            "+        String attributeValue;\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.CLASS));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            try {\n", 
            "+                mediator.setClazz(Class.forName(attributeValue.trim()));\n", 
            "+            } catch (Exception e) {\n", 
            "+                handleException(\"Error while loading '\" + attributeValue + \"' class.\", e);\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            handleException(\"'class' attribute of Bean mediator is required when 'CREATE' action \" +\n", 
            "+                    \"is set.\");\n", 
            "+        }\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.REPLACE));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setReplace(Boolean.parseBoolean(attributeValue.trim()));\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    private void populateSetPropertyCase(BeanMediator mediator, OMElement elem) {\n", 
            "+\n", 
            "+        mediator.setAction(BeanMediator.Action.SET_PROPERTY);\n", 
            "+\n", 
            "+        populatePropertyName(mediator, elem);\n", 
            "+\n", 
            "+        if (elem.getAttributeValue(ATT_VALUE) != null) {\n", 
            "+            mediator.setValue(new ValueFactory().createValue(BeanConstants.VALUE, elem));\n", 
            "+        } else {\n", 
            "+            handleException(\"'value' attribute of Bean mediator is required when 'SET_PROPERTY' \" +\n", 
            "+                    \"action is set.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void populateGetPropertyCase(BeanMediator mediator, OMElement elem) {\n", 
            "+\n", 
            "+        mediator.setAction(BeanMediator.Action.GET_PROPERTY);\n", 
            "+\n", 
            "+        populatePropertyName(mediator, elem);\n", 
            "+\n", 
            "+        if (elem.getAttributeValue(new QName(BeanConstants.TARGET)) != null) {\n", 
            "+            mediator.setTarget(new Target(BeanConstants.TARGET, elem));\n", 
            "+        } else {\n", 
            "+            handleException(\"'target' attribute of Bean mediator is required when 'GET_PROPERTY' \" +\n", 
            "+                    \"action is set.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void populatePropertyName(BeanMediator mediator, OMElement elem) {\n", 
            "+\n", 
            "+        String attributeValue;\n", 
            "+\n", 
            "+        attributeValue = elem.getAttributeValue(new QName(BeanConstants.PROPERTY));\n", 
            "+        if (attributeValue != null) {\n", 
            "+            mediator.setPropertyName(attributeValue);\n", 
            "+        } else {\n", 
            "+            handleException(\"'property' attribute of Bean mediator is required when \" +\n", 
            "+                    \"SET/GET_PROPERTY action is set.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public QName getTagQName() {\n", 
            "+        return BEAN_Q;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/BeanMediatorFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/BeanMediatorFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-83,7 +83,9", 
          "lines": [
            "         MessageStoreMediatorFactory.class,\n", 
            "         TemplateMediatorFactory.class,\n", 
            "         InvokeMediatorFactory.class,\n", 
            "-        PayloadFactoryMediatorFactory.class\n", 
            "+        PayloadFactoryMediatorFactory.class,\n", 
            "+        BeanMediatorFactory.class,\n", 
            "+        EJBMediatorFactory.class\n", 
            "     };\n", 
            " \n", 
            "     private final static MediatorFactoryFinder instance  = new MediatorFactoryFinder();\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MediatorFactoryFinder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MediatorFactoryFinder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-69,7 +69,9", 
          "lines": [
            "         InvokeMediatorSerializer.class,\n", 
            "         MessageStoreMediatorSerializer.class,\n", 
            "         URLRewriteMediatorSerializer.class,\n", 
            "-        PayloadFactoryMediatorSerializer.class\n", 
            "+        PayloadFactoryMediatorSerializer.class,\n", 
            "+        BeanMediatorSerializer.class,\n", 
            "+        EJBMediatorSerializer.class\n", 
            "     };\n", 
            " \n", 
            "     private final static MediatorSerializerFinder instance = new MediatorSerializerFinder();\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MediatorSerializerFinder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MediatorSerializerFinder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,118", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.mediators.Value;\n", 
            "+import org.apache.synapse.mediators.bean.BeanConstants;\n", 
            "+import org.apache.synapse.mediators.bean.enterprise.EJBConstants;\n", 
            "+import org.apache.synapse.mediators.bean.enterprise.EJBMediator;\n", 
            "+\n", 
            "+import java.util.List;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Serializer for {@link EJBMediator} instances.\n", 
            "+ *\n", 
            "+ * @see EJBMediatorFactory\n", 
            "+ */\n", 
            "+public class EJBMediatorSerializer extends AbstractMediatorSerializer {\n", 
            "+\n", 
            "+    private static final String EJB = \"ejb\";\n", 
            "+\n", 
            "+    public OMElement serializeSpecificMediator(Mediator m) {\n", 
            "+\n", 
            "+        if (!(m instanceof EJBMediator)) {\n", 
            "+            handleException(\"An unsupported mediator was passed in for serialization : \" +\n", 
            "+                    m.getType());\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+\n", 
            "+        EJBMediator mediator = (EJBMediator) m;\n", 
            "+\n", 
            "+        OMElement mediatorElem = fac.createOMElement(EJB, synNS);\n", 
            "+        saveTracingState(mediatorElem, mediator);\n", 
            "+\n", 
            "+        if (mediator.getBeanstalkName() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    EJBConstants.BEANSTALK, nullNS, mediator.getBeanstalkName()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getClassName() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    BeanConstants.CLASS, nullNS, mediator.getClassName()));\n", 
            "+        } else {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getSessionId() != null) {\n", 
            "+            new ValueSerializer().serializeValue(\n", 
            "+                    mediator.getSessionId(), EJBConstants.SESSION_ID, mediatorElem);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getMethod() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    EJBConstants.METHOD, nullNS, mediator.getMethod().getName()));\n", 
            "+        } else if (!mediator.isRemove()) {\n", 
            "+            handleException();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getTarget() != null) {\n", 
            "+            mediator.getTarget().serializeTarget(BeanConstants.TARGET, mediatorElem);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.getJndiName() != null) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    EJBConstants.JNDI_NAME, nullNS, mediator.getJndiName()));\n", 
            "+        }\n", 
            "+\n", 
            "+        if (mediator.isRemove()) {\n", 
            "+            mediatorElem.addAttribute(fac.createOMAttribute(\n", 
            "+                    EJBConstants.REMOVE, nullNS, Boolean.toString(true)));\n", 
            "+        }\n", 
            "+\n", 
            "+        List<Value> argList = mediator.getArgumentList();\n", 
            "+\n", 
            "+        if (argList != null && argList.size() > 0) {\n", 
            "+\n", 
            "+            OMElement argumentsElem = fac.createOMElement(EJBConstants.ARGS, synNS);\n", 
            "+\n", 
            "+            for (Value arg : argList) {\n", 
            "+                OMElement argElem = fac.createOMElement(EJBConstants.ARG, synNS);\n", 
            "+                new ValueSerializer().serializeValue(arg, BeanConstants.VALUE, argElem);\n", 
            "+                argumentsElem.addChild(argElem);\n", 
            "+            }\n", 
            "+\n", 
            "+            mediatorElem.addChild(argumentsElem);\n", 
            "+        }\n", 
            "+\n", 
            "+        return mediatorElem;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getMediatorClassName() {\n", 
            "+        return EJBMediator.class.getName();\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleException() {\n", 
            "+        handleException(\"Invalid ejb mediator was passed in for serialization.\");\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EJBMediatorSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EJBMediatorSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,150", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.commons.util.MiscellaneousUtil;\n", 
            "+\n", 
            "+import java.util.Iterator;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Properties;\n", 
            "+import java.util.concurrent.ConcurrentHashMap;\n", 
            "+import java.util.concurrent.Executors;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+import java.util.concurrent.ThreadFactory;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Manages Enterprise Beanstalks configured in the Synapse Environment. Only one instance of this\n", 
            "+ * class is created per Synapse environment.\n", 
            "+ */\n", 
            "+public class EnterpriseBeanstalkManager {\n", 
            "+\n", 
            "+    private final static Log log = LogFactory.getLog(EnterpriseBeanstalkManager.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Stores all configured enterprise beanstalks.\n", 
            "+     */\n", 
            "+    private Map<String, EnterpriseBeanstalk> beanstalkMap = new ConcurrentHashMap<String, EnterpriseBeanstalk>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * ScheduledExecutorService for cleaning up timed out client stubs in all beanstalks.\n", 
            "+     */\n", 
            "+    private ScheduledExecutorService scheduler;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Initializes the beanstalk manager, which creates and initializes beanstalks defined in the\n", 
            "+     * given Properties instance.\n", 
            "+     * @param props Properties to read enterprise beanstalk configurations from. Usually, source of\n", 
            "+     * this is synapse.properties file.\n", 
            "+     */\n", 
            "+    public void init(Properties props) {\n", 
            "+\n", 
            "+        if (props == null) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Enterprise Beanstalk properties cannot be found.\");\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        String beanstalkNameList = MiscellaneousUtil.getProperty(props,\n", 
            "+                EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX, null);\n", 
            "+\n", 
            "+        if (beanstalkNameList == null || \"\".equals(beanstalkNameList)) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"No beanstalks defined for initialization.\");\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        String[] beanstalkNames = beanstalkNameList.split(\",\");\n", 
            "+        if (beanstalkNames == null || beanstalkNames.length == 0) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"No beanstalk definitions found for initialization.\");\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        scheduler = Executors.newSingleThreadScheduledExecutor(\n", 
            "+                new ThreadFactory() {\n", 
            "+                    public Thread newThread(Runnable r) {\n", 
            "+                        return new Thread(r, \"enterprise-beanstalk-cache-cleaner\");\n", 
            "+                    }\n", 
            "+                }\n", 
            "+        );\n", 
            "+\n", 
            "+        for (String beanstalkName : beanstalkNames) {\n", 
            "+\n", 
            "+            if (beanstalkName == null || beanstalkName.trim().length() == 0) {\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+\n", 
            "+            String propertyPrefix = EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX + \".\" +\n", 
            "+                    beanstalkName + \".\";\n", 
            "+            Properties currentBeanstalkProps = new Properties();\n", 
            "+\n", 
            "+            for (Map.Entry<Object, Object> entry : props.entrySet()) {\n", 
            "+\n", 
            "+                if (entry.getKey() instanceof String && entry.getValue() instanceof String) {\n", 
            "+\n", 
            "+                    String key = (String) entry.getKey();\n", 
            "+                    if (key.startsWith(propertyPrefix)) {\n", 
            "+                        currentBeanstalkProps.setProperty(\n", 
            "+                                        key.replace(propertyPrefix, \"\"), (String) entry.getValue());\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            EnterpriseBeanstalk beanstalk =\n", 
            "+                    new EnterpriseBeanstalk(beanstalkName, currentBeanstalkProps, scheduler);\n", 
            "+            beanstalk.init();\n", 
            "+\n", 
            "+            beanstalkMap.put(beanstalkName, beanstalk);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the beanstalk with the given name, null if it's not found.\n", 
            "+     * @param name Name of the beanstalk.\n", 
            "+     * @return Beanstalk specified by the name, null if it's not found.\n", 
            "+     */\n", 
            "+    public EnterpriseBeanstalk getEnterpriseBeanstalk(String name) {\n", 
            "+        return beanstalkMap.get(name);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Cleans up resources allocated by this BeanstalkManager.\n", 
            "+     */\n", 
            "+    public void destroy() {\n", 
            "+\n", 
            "+        Iterator<EnterpriseBeanstalk> it = beanstalkMap.values().iterator();\n", 
            "+        while (it.hasNext()) {\n", 
            "+            it.next().destroy();\n", 
            "+            it.remove();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (scheduler != null && !scheduler.isShutdown()) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Shutting down enterprise beanstalk cache cleaner executor...\");\n", 
            "+            }\n", 
            "+            scheduler.shutdownNow();\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkManager.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkManager.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,76", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+import java.util.Date;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+/**\n", 
            "+ * MBean implementation class that enables monitoring/managing enterprise beanstalks via JMX.\n", 
            "+ */\n", 
            "+public class EnterpriseBeanstalkView implements EnterpriseBeanstalkViewMBean {\n", 
            "+\n", 
            "+    private EnterpriseBeanstalk beanstalk;\n", 
            "+\n", 
            "+    EnterpriseBeanstalkView(EnterpriseBeanstalk beanstalk) {\n", 
            "+        this.beanstalk = beanstalk;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getBeanstalkName() {\n", 
            "+        return beanstalk.getName();\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getCachedStatelessStubCount() {\n", 
            "+        return beanstalk.getStatelessBeans().size();\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getCachedStatefulStubCount() {\n", 
            "+        return beanstalk.getStatefulBeans().size();\n", 
            "+    }\n", 
            "+\n", 
            "+    public Map getStatelessStubCacheLastAccessTimes() {\n", 
            "+        return getLastAccessTimesMap(beanstalk.getStatelessBeans());\n", 
            "+    }\n", 
            "+\n", 
            "+    public Map getStatefulStubCacheLastAccessTimes() {\n", 
            "+        return getLastAccessTimesMap(beanstalk.getStatefulBeans());\n", 
            "+    }\n", 
            "+\n", 
            "+    private Map getLastAccessTimesMap(Map<String, CacheEntry> beanMap) {\n", 
            "+        Map<String, Date> results = new HashMap<String, Date>();\n", 
            "+        for (Map.Entry<String, CacheEntry> entry : beanMap.entrySet()) {\n", 
            "+            results.put(entry.getKey(), new Date(entry.getValue().getLastAccessTime()));\n", 
            "+        }\n", 
            "+        return results;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void cleanExpiredStubsNow() throws Exception {\n", 
            "+        beanstalk.removeExpiredBeans();\n", 
            "+    }\n", 
            "+\n", 
            "+    public void removeStatelessStub(String className) {\n", 
            "+        beanstalk.removeEnterpriseBean(className, null);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void removeStatefulStub(String className, String sessionId) {\n", 
            "+        beanstalk.removeEnterpriseBean(className, sessionId);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkView.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkView.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,74", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Holds constants used in Enterprise Beanstalk configurations.\n", 
            "+ */\n", 
            "+public interface EnterpriseBeanstalkConstants {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Prefix for beanstalk related configuration property names in synapse.properties.\n", 
            "+     */\n", 
            "+    public static final String SYNAPSE_BEANSTALK_PREFIX = \"synapse.beanstalks\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Cache timeout in minutes for stateless session beans\n", 
            "+     */\n", 
            "+    public static final String STATELESS_BEANS_TIMEOUT = \"cache.timeout.stateless\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Cache timeout in minutes for stateful session beans\n", 
            "+     */\n", 
            "+    public static final String STATEFUL_BEANS_TIMEOUT = \"cache.timeout.stateful\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Warn limit for stateless session beans. A warning is generated when more than this many of\n", 
            "+     * stateless bean stubs are cached in this beanstalk.\n", 
            "+     */\n", 
            "+    public static final String STATELESS_BEANS_WARN_LIMIT = \"cache.warn.limit.stateless\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Warn limit for stateless session beans. A warning is generated when more than this many of\n", 
            "+     * stateless bean stubs are cached in this beanstalk.\n", 
            "+     */\n", 
            "+    public static final String STATEFUL_BEANS_WARN_LIMIT = \"cache.warn.limit.stateful\";\n", 
            "+\n", 
            "+\n", 
            "+    // -------------------- Internally used constants -------------------- //\n", 
            "+\n", 
            "+    /**\n", 
            "+     * ServerContextInformation property name of the EnterpriseBeanstalkManager.\n", 
            "+     */\n", 
            "+    public static final String ENTERPRISE_BEANSTALK_MANAGER_PROP_NAME =\n", 
            "+                                                       \"__SYNAPSE.ENTERPRISE.BEANSTALK.MANAGER\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * ServerContextInformation property name of the EnterpriseBeanstalkManager configuration.\n", 
            "+     */\n", 
            "+    public static final String ENTERPRISE_BEANSTALK_CONFIG_PROP_NAME =\n", 
            "+                                                       \"__SYNAPSE.ENTERPRISE.BEANSTALK.CONFIG\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Category name for JMX MBeans registered to monitor beanstalks.\n", 
            "+     */\n", 
            "+    public static final String ENTERPRISE_BEANSTALK_MBEAN_CATEGORY_NAME = \"EnterpriseBeanstalk\";\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkConstants.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,47", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+/**\n", 
            "+ * MBean interface that enables monitoring/managing enterprise beanstalks via JMX.\n", 
            "+ */\n", 
            "+public interface EnterpriseBeanstalkViewMBean {\n", 
            "+\n", 
            "+    // JMX Attributes\n", 
            "+    public String getBeanstalkName();\n", 
            "+\n", 
            "+    public int getCachedStatelessStubCount();\n", 
            "+\n", 
            "+    public int getCachedStatefulStubCount();\n", 
            "+\n", 
            "+    public Map getStatelessStubCacheLastAccessTimes();\n", 
            "+\n", 
            "+    public Map getStatefulStubCacheLastAccessTimes();\n", 
            "+\n", 
            "+\n", 
            "+    // JMX Operations\n", 
            "+    public void cleanExpiredStubsNow() throws Exception;\n", 
            "+\n", 
            "+    public void removeStatelessStub(String className);\n", 
            "+\n", 
            "+    public void removeStatefulStub(String className, String sessionId);\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkViewMBean.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalkViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,52", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+/**\n", 
            "+ * CacheEntry records last access time of the EJB client stub it encapsulates.\n", 
            "+ */\n", 
            "+class CacheEntry {\n", 
            "+\n", 
            "+    private long lastAccessTime;\n", 
            "+\n", 
            "+    private final Object bean;\n", 
            "+\n", 
            "+    CacheEntry(Object bean) {\n", 
            "+        this.lastAccessTime = System.currentTimeMillis();\n", 
            "+        this.bean = bean;\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized long getLastAccessTime() {\n", 
            "+        return lastAccessTime;\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void setLastAccessTime(long lastAccessTime) {\n", 
            "+        this.lastAccessTime = lastAccessTime;\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void markLastAccessTime() {\n", 
            "+        this.lastAccessTime = System.currentTimeMillis();\n", 
            "+    }\n", 
            "+\n", 
            "+    public Object getBean() {\n", 
            "+        return bean;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/CacheEntry.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/CacheEntry.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,341", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.commons.beanstalk.enterprise;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.commons.jmx.MBeanRegistrar;\n", 
            "+\n", 
            "+import javax.naming.InitialContext;\n", 
            "+import javax.naming.NamingException;\n", 
            "+import java.util.*;\n", 
            "+import java.util.concurrent.ConcurrentHashMap;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+import java.util.concurrent.ScheduledFuture;\n", 
            "+import java.util.concurrent.TimeUnit;\n", 
            "+\n", 
            "+/**\n", 
            "+ * An Enterprise Beanstalk is used to retrieve Enterprise JavaBean (EJB) client stubs. This class\n", 
            "+ * implements Service Locator J2EE pattern and supports stateless and stateful session beans.\n", 
            "+ * Enterprise beanstalks can be configured in synapse.properties file. Parameters of the JNDI\n", 
            "+ * service to be looked up for EJBs should be provided with this configuration.\n", 
            "+ * Beanstalks cache EJB client stubs to improve efficiency by omitting excessive JNDI\n", 
            "+ * context creation and look ups. Cache timeout for both stateless and stateful session beans could\n", 
            "+ * be configured independently.\n", 
            "+ */\n", 
            "+public class EnterpriseBeanstalk {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(EnterpriseBeanstalk.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Name of the beanstalk\n", 
            "+     */\n", 
            "+    private String name;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Properties used while initializing this beanstalk.\n", 
            "+     */\n", 
            "+    private Properties props;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Executor that periodically runs the Cleaner.\n", 
            "+     */\n", 
            "+    private ScheduledExecutorService scheduler;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Scheduled future that represents the scheduled Cleaner.\n", 
            "+     */\n", 
            "+    private ScheduledFuture<?> scheduledFuture;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Cache timeout for stateless session bean stubs.\n", 
            "+     */\n", 
            "+    private int statelessBeanTimeoutMinutes = 30;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Cache timeout for stateful session bean stubs.\n", 
            "+     */\n", 
            "+    private int statefulBeanTimeoutMinutes = 30;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Warn limit for stateless session beans. A warning is generated when more than this many of\n", 
            "+     * stateless bean stubs are cached by this beanstalk.\n", 
            "+     */\n", 
            "+    private int statelessBeanWarnLimit = Short.MAX_VALUE;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Warn limit for stateful session beans. A warning is generated when more than this many of\n", 
            "+     * stateful bean stubs are cached by this beanstalk.\n", 
            "+     */\n", 
            "+    private int statefulBeanWarnLimit = Short.MAX_VALUE;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * JNDI context constructed with the properties provided while initializing this beanstalk.\n", 
            "+     */\n", 
            "+    private InitialContext initialCtx;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Stateless session bean stub cache.\n", 
            "+     */\n", 
            "+    private Map<String, CacheEntry> statelessBeans = new ConcurrentHashMap<String, CacheEntry>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Stateful session bean stub cache.\n", 
            "+     */\n", 
            "+    private Map<String, CacheEntry> statefulBeans = new ConcurrentHashMap<String, CacheEntry>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Constructs a new enterprise beanstalk with the given name and properties.\n", 
            "+     * @param name Name of the enterprise beanstalk.\n", 
            "+     * @param props Configuration properties. This should include properties of the JNDI service\n", 
            "+     * to be looked up for EJBs.\n", 
            "+     * @param scheduler ScheduledExecutorService for cleaning up timed-out stubs.\n", 
            "+     */\n", 
            "+    public EnterpriseBeanstalk(String name, Properties props, ScheduledExecutorService scheduler) {\n", 
            "+        this.name = name;\n", 
            "+        this.scheduler = scheduler;\n", 
            "+        this.props = props;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Initialize the current beanstalk by creating the JNDI context, registering the MBean etc.\n", 
            "+     */\n", 
            "+    public void init() {\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Initializing Beanstalk: \" + name);\n", 
            "+        }\n", 
            "+\n", 
            "+        // Initialize the JNDI context.\n", 
            "+        try {\n", 
            "+            initialCtx = new InitialContext(props);\n", 
            "+        } catch (NamingException e) {\n", 
            "+            log.error(\"Could not initialize JNDI context for the Enterprise Beanstalk \" +\n", 
            "+                    \"named '\" + name + \"'.\", e);\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        // Read settings from the provided properties.\n", 
            "+        if (props != null) {\n", 
            "+            String value;\n", 
            "+\n", 
            "+            value = props.getProperty(EnterpriseBeanstalkConstants.STATELESS_BEANS_TIMEOUT);\n", 
            "+            if (value != null) {\n", 
            "+                statelessBeanTimeoutMinutes = Integer.parseInt(value);\n", 
            "+            }\n", 
            "+\n", 
            "+            value = props.getProperty(EnterpriseBeanstalkConstants.STATEFUL_BEANS_TIMEOUT);\n", 
            "+            if (value != null) {\n", 
            "+                statefulBeanTimeoutMinutes = Integer.parseInt(value);\n", 
            "+            }\n", 
            "+\n", 
            "+            value = props.getProperty(EnterpriseBeanstalkConstants.STATELESS_BEANS_WARN_LIMIT);\n", 
            "+            if (value != null) {\n", 
            "+                statelessBeanWarnLimit = Integer.parseInt(value);\n", 
            "+            }\n", 
            "+\n", 
            "+            value = props.getProperty(EnterpriseBeanstalkConstants.STATEFUL_BEANS_WARN_LIMIT);\n", 
            "+            if (value != null) {\n", 
            "+                statefulBeanWarnLimit = Integer.parseInt(value);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        // Schedule the cleaner that removes expired beans periodically.\n", 
            "+        int minDelay = Math.min(statelessBeanTimeoutMinutes, statefulBeanTimeoutMinutes);\n", 
            "+        scheduledFuture = scheduler.scheduleWithFixedDelay(\n", 
            "+                            new Runnable() {\n", 
            "+                                public void run() {\n", 
            "+                                    removeExpiredBeans();\n", 
            "+                                }\n", 
            "+                            }, minDelay, minDelay, TimeUnit.MINUTES);\n", 
            "+\n", 
            "+        // Register the MBean for this beanstalk.\n", 
            "+        MBeanRegistrar.getInstance().registerMBean(new EnterpriseBeanstalkView(this),\n", 
            "+                EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MBEAN_CATEGORY_NAME, name);\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Successfully initialized Beanstalk: \" + name);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Destroys the beanstalk by performing clean up.\n", 
            "+     */\n", 
            "+    public void destroy() {\n", 
            "+\n", 
            "+        scheduledFuture.cancel(false);\n", 
            "+\n", 
            "+        MBeanRegistrar.getInstance().unRegisterMBean(\n", 
            "+                EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MBEAN_CATEGORY_NAME, name);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the name of this beanstalk.\n", 
            "+     *\n", 
            "+     * @return Name of the beanstalk.\n", 
            "+     */\n", 
            "+    public String getName() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns a client stub for the EJB with given class name, session id and jndi name. If the\n", 
            "+     * stub is already available in cache, it is retrieved from there. Otherwise, a JNDI lookup\n", 
            "+     * is performed with the given JNDI name.\n", 
            "+     *\n", 
            "+     * @param className Fully qualified name of the remote interface of the session bean.\n", 
            "+     * @param sessionId Session id for stateful beans. null for stateless ones.\n", 
            "+     * @param jndiName JNDI name of the EJB. null could be used if the bean is already available in\n", 
            "+     * the cache.\n", 
            "+     * @return Retrieved EJB client stub. null if the EJB is not found.\n", 
            "+     */\n", 
            "+    public Object getEnterpriseBean(String className, String sessionId, String jndiName) {\n", 
            "+        return sessionId == null ?\n", 
            "+            findEjb(statelessBeans, className, sessionId, jndiName, statelessBeanWarnLimit) :\n", 
            "+            findEjb(statefulBeans, className, sessionId, jndiName, statefulBeanWarnLimit);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Remove the specified client stub from cache. If the stub is not removed using this\n", 
            "+     * method it will be automatically removed from the beanstalk after it times out.\n", 
            "+     * @param className Fully qualified name of the remote interface of the session bean.\n", 
            "+     * @param sessionId Session id for stateful session beans, null for stateless ones.\n", 
            "+     * @return EJB client stub that was removed from the beanstalk.\n", 
            "+     */\n", 
            "+    public Object removeEnterpriseBean(String className, String sessionId) {\n", 
            "+        return (sessionId == null) ?\n", 
            "+                statelessBeans.remove(getMapKey(className, sessionId)) :\n", 
            "+                statefulBeans.remove(getMapKey(className, sessionId));\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Removes expired stateless and stateful bean stubs from cache. Timeouts are configurable.\n", 
            "+     */\n", 
            "+    public void removeExpiredBeans() {\n", 
            "+        removeExpiredBeansFromMap(statelessBeans, statelessBeanTimeoutMinutes);\n", 
            "+        removeExpiredBeansFromMap(statefulBeans, statefulBeanTimeoutMinutes);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Retrieves an EJB client stub from the cache, looks up in the JNDI service if it is not\n", 
            "+     * available in the cache. If the bean is found from JNDI lookup, it is added to the cache.\n", 
            "+     *\n", 
            "+     * @param map Cache to search the stub in.\n", 
            "+     * @param className Fully qualified name of the remote interface of the session bean.\n", 
            "+     * @param sessionId Session id for stateful beans. null for stateless ones.\n", 
            "+     * @param jndiName JNDI name of the EJB. null could be used if the bean is already available in\n", 
            "+     * the cache.\n", 
            "+     * @param warnLimit If this many of stubs are already available in the cache, a warning is\n", 
            "+     * generated before adding a new stub to it.\n", 
            "+     * @return Retrieved EJB client stub. null if the EJB is not found.\n", 
            "+     */\n", 
            "+    private Object findEjb(Map<String, CacheEntry> map, String className, String sessionId,\n", 
            "+                           String jndiName, int warnLimit) {\n", 
            "+\n", 
            "+        CacheEntry entry = map.get(getMapKey(className, sessionId));\n", 
            "+\n", 
            "+        if (entry == null && jndiName != null) {\n", 
            "+\n", 
            "+            synchronized (this) {\n", 
            "+                entry = map.get(getMapKey(className, sessionId));\n", 
            "+                if (entry == null) {\n", 
            "+                    Object ejb = lookupInJndi(jndiName);\n", 
            "+                    if (ejb != null) {\n", 
            "+                        map.put(getMapKey(className, sessionId), entry = new CacheEntry(ejb));\n", 
            "+                        int size = map.size();\n", 
            "+                        if (size > warnLimit) {\n", 
            "+                            String type = sessionId == null ? \"stateless\" : \"stateful\";\n", 
            "+                            log.warn(\"Warn limit reached for \" + type + \" beans. Currently there \" +\n", 
            "+                                    \"are \" + size + \" \" + type + \" EJB stubs cached in '\" + name +\n", 
            "+                                    \"' \" + \"beanstalk.\");\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+\n", 
            "+        if (entry == null) {\n", 
            "+            return null;\n", 
            "+        } else {\n", 
            "+            entry.markLastAccessTime();\n", 
            "+            return entry.getBean();\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Looks up the given resource in the JNDI service.\n", 
            "+     * @param jndiName JNDI name of the resource (EJB).\n", 
            "+     * @return Resource retrieved from the JNDI lookup. null if no resource is found.\n", 
            "+     */\n", 
            "+    private Object lookupInJndi(String jndiName) {\n", 
            "+        try {\n", 
            "+            return initialCtx.lookup(jndiName);\n", 
            "+        } catch (NamingException ex) {\n", 
            "+            log.error(\"Lookup failed for JNDI name: \" + jndiName, ex);\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Remove stubs from the given map that have not been used for a time period longer than the\n", 
            "+     * provided timeout.\n", 
            "+     * @param map Bean stub cache.\n", 
            "+     * @param timeoutInMinutes Expiry timeout.\n", 
            "+     */\n", 
            "+    private void removeExpiredBeansFromMap(Map<String, CacheEntry> map, int timeoutInMinutes) {\n", 
            "+\n", 
            "+        Iterator<Map.Entry<String, CacheEntry>> itr = map.entrySet().iterator();\n", 
            "+\n", 
            "+        while (itr.hasNext()) {\n", 
            "+\n", 
            "+            Map.Entry<String, CacheEntry> mapEntry = itr.next();\n", 
            "+\n", 
            "+            if (System.currentTimeMillis() - mapEntry.getValue().getLastAccessTime() >\n", 
            "+                                                        timeoutInMinutes * 60L * 1000L) {\n", 
            "+\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Removing the timed-out EJB stub with key '\" + mapEntry.getKey() +\n", 
            "+                            \"', from '\" + name + \"' beanstalk cache.\");\n", 
            "+                }\n", 
            "+                itr.remove();\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Derives the map key for this session bean.\n", 
            "+     * @param className Fully qualified name of the remote interface of the EJB.\n", 
            "+     * @param sessionId Session Id for stateful beans, null for stateless ones.\n", 
            "+     * @return Map key derived from the given parameters.\n", 
            "+     */\n", 
            "+    private String getMapKey(String className, String sessionId) {\n", 
            "+        return sessionId == null ? className : className + \"-\" + sessionId;\n", 
            "+    }\n", 
            "+\n", 
            "+    Map<String, CacheEntry> getStatelessBeans() {\n", 
            "+        return statelessBeans;\n", 
            "+    }\n", 
            "+\n", 
            "+    Map<String, CacheEntry> getStatefulBeans() {\n", 
            "+        return statefulBeans;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalk.java", 
      "from": "java/modules/commons/src/main/java/org/apache/synapse/commons/beanstalk/enterprise/EnterpriseBeanstalk.java"
    }
  ], 
  "id": "1361639"
}